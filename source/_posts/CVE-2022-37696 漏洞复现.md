---
title: 'CVE-2022-37696 漏洞复现'
date: 2022-10-22 14:22:05
category: CVE
tags: [windows kernel, clfs]
published: true
hideInList: false
feature: 
isTop: false
---
## 环境

```
虚拟机：Win10 21h2 19044.1889
物理机：Win10
debugger：windbg preview
compiler：vs2022
```

环境我使用的是`Win10 21h2`官方8月的版本

## 简述漏洞

在`blf`文件`Base Log Record`区域的`cbSymbolZone`字段的检测被绕过，从而导致畸形的`cbSymbolZone`（即越界的`cbSymbolZone`）可以被使用，从而可以在任意偏移位置进行越界写。

这个检测被绕过，跟`Base Log Record`区域头的`SignaturesOffset`字段相关，原本利用`SignaturesOffset`字段进行检测，但是存在另外一个漏洞，利用不正确的`SignaturesOffset`，可以进行任意地址写入`0xffff`，从而又覆盖`SignaturesOffset`高位的2个字节，从而可以使得大数`cbSymbolZone`可以绕过检测

## 漏洞分析

### POC 总览

可以通过[参考链接](https://www.zscaler.com/blogs/security-research/technical-analysis-windows-clfs-zero-day-vulnerability-cve-2022-37969-part)的`POC.png`对该漏洞的利用进行大概了解

![POC](/img/CVE-2022-37696/POC.png)

其核心主要在步骤3省略的部分，即对于初始化的`MyLog.blf`进行修改，然后再对于已经做了改动的`MyLog.blf`进行解析（P.S. 如果`v51`无法打开成功的话，其实就是已经被`patch`了），并且在此时，把这个文件设置成`GENERIC_READ | GENERIC_WRITE | DELETE`

最后在`MyLog.blf`进行`AddLogContainer`会溢出覆盖到之前`MyLxg_xxx.blf`的`pContainer`指针上，从而导致`BSOD`

### MyLog.blf 的修改

参考链接的对于`MyLog.blf`修改的归总如下（P.S. 下图中的0x86C是写错了的，应该是`0x868`）

![010](/img/CVE-2022-37696/010.png)

![diff](/img/CVE-2022-37696/diff.png)

**SignaturesOffset**

`0x0868: |80 79 00 00| => |50 00 00 00|`
这个修改不确定有没有用，最终`50 00 00 00`会被漏洞修改为`50 00 ff ff`从而实现绕过

**rgClients**

`0x09a8: |68 13 00 00| => |30 1B 00 00|`
相当于把一个`0x1386`的`Offset`修改为了`0x1B30`，相当于`0x1BD8=0x1386+0x870`的`Client Context`被弃用，在`0x23A0=0x1B30+0x870`的地方，重新伪造了一个`Client Context`结构体

**cbSymbolZone**

`0x1B98: |F8 00 00 00| => |4B 11 01 00|		cbSymbolZone		0x1114B`
改大`cbSymbolZone`，以使得`AddLogContainer`时，会造成堆越界写

**Client Context**

`0x2390: |00 00 00 00 00 00 00 00| => |B8 1B 00 00 30 1B 00 00|`
该字段的修改是为了伪造的`FakeClientContext`能过检测

![FakeClientContext](/img/CVE-2022-37696/FakeClientContext.png)
在`CLFS_LOG_STATE eState`字段设置为了`CLFS_LOG_SHUTDOWN 0x20`

### 畸形 SignaturesOffset 的影响

构造了一个畸形的`.blf`，然后再次打开时，会对于该`blf`进行解析

`HANDLE v51 = CreateLogFile(L"LOG:C:\\Users\\Public\\MyLog", GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS, NULL);`

函数`CClfsLogFcbPhysical::Initialize`会进行解析

```
open evil MyLog.blf
0: kd> k
 # Child-SP          RetAddr               Call Site
00 ffffeb07`b8d56238 fffff807`6e39eaeb     CLFS!CClfsLogFcbPhysical::Initialize
01 ffffeb07`b8d56240 fffff807`6e3a0a2b     CLFS!CClfsRequest::Create+0x4ef
02 ffffeb07`b8d56390 fffff807`6e3a07f7     CLFS!CClfsRequest::Dispatch+0x97
03 ffffeb07`b8d563e0 fffff807`6e3a0747     CLFS!ClfsDispatchIoRequest+0x87
```

P.S 以下调用函数都是由`CClfsLogFcbPhysical::Initialize`函数直接调用的，都在`CClfsLogFcbPhysical::Initialize`函数中

#### Signatures 数组的 Decode

在`CClfsBaseFilePersisted::OpenImage`中，主要会把`SignaturesOffset`偏移处的`Signatures`数组的内容`Decode`写入内存对应位置

下图为`CClfsLogFcbPhysical::Initialize`中对于`CClfsBaseFilePersisted::OpenImage`的调用

![OpenImageIDA](/img/CVE-2022-37696/OpenImageIDA.png)

在会走到`CClfsBaseFilePersisted::ReadMetadataBlock`时，会调用`ClfsDecodeBlock`实现上述`Decode`功能

![ReadMetadataBlock](/img/CVE-2022-37696/ReadMetadataBlock.png)

进入`ClfsDecodeBlock`时的调用栈如下

```
0: kd> k
 # Child-SP          RetAddr               Call Site
00 ffffeb07`b6f40f48 fffff807`6e3a4192     CLFS!ClfsDecodeBlock
01 ffffeb07`b6f40f50 fffff807`6e3aa395     CLFS!CClfsBaseFilePersisted::ReadMetadataBlock+0x182
02 ffffeb07`b6f40ff0 fffff807`6e3aa204     CLFS!CClfsBaseFile::AcquireMetadataBlock+0x45
03 ffffeb07`b6f41020 fffff807`6e3a9c36     CLFS!CClfsBaseFilePersisted::ReadImage+0x1e8
04 ffffeb07`b6f41080 fffff807`6e372da2     CLFS!CClfsBaseFilePersisted::OpenImage+0x2fa
05 ffffeb07`b6f41100 fffff807`6e39eaeb     CLFS!CClfsLogFcbPhysical::Initialize+0x326
06 ffffeb07`b6f41240 fffff807`6e3a0a2b     CLFS!CClfsRequest::Create+0x4ef
```

`ClfsDecodeBlock`函数会循环将`signArray`的内容取出，放入`base+0x200*N+0x1FE`的地方去，因此`0x0050`会被写入`13th`(`(0x68-0x50)/2+1`)的`sector`的`Signature`地方

![ClfsDecodeBlockIDA](/img/CVE-2022-37696/ClfsDecodeBlockIDA.png)

![ClfsDecodeBlockWindbg](/img/CVE-2022-37696/ClfsDecodeBlockWindbg.png)

P.S 这个`0x0050`后续会被写回来；这个 `signArray` 都是2个字节大小的

P.S. [clfs-docs](https://github.com/ionescu007/clfs-docs/) 有对于这个每个`sector`的签名数组的详细说明，其实这里的`decode`和`encode`其实就是：当从磁盘中读`blf`时，解析该数组，以恢复这个`sector`的内存；从`sector`内存获取值，以存储到这个数组中。

`When reading the Base Log File from disk, it is critical to parse this array, and take each 2 bytes and overlay them on top of the signature bytes of each corresponding sector (restoring the original data bytes).`

#### Fake Client Context 的解析

在`CClfsBaseFile::AcquireClientContext`中，主要会获取`Fake Client Context`，从而写到一个`sector`的

下图为`CClfsLogFcbPhysical::Initialize`中对于`CClfsBaseFile::AcquireClientContext`的调用

![AcquireClientContextIDA](/img/CVE-2022-37696/AcquireClientContextIDA.png)

在`CClfsBaseFile::AcquireClientContext`中调用`CClfsBaseFile::GetSymbol`获取`1st rgClients`的内容

![GetSymbolIDA](/img/CVE-2022-37696/GetSymbolIDA.png)

其中对于`fake client context`之前的内容修改，就是为了过这里的检测，可以通过查看原来的`real client context`查看这个检测，`0x13f0 = 0x1368+0x88 | 0x1bd8 = 0x1368+0x870`，因此最后的地方应该是`0x1b30+0x88=0x1bb8`

![RealClientContext](/img/CVE-2022-37696/RealClientContext.png)

#### ResetLog 覆盖 sector 的 signature 

这里`v75`为`fake client context`，为了能走到`CClfsLogFcbPhysical::ResetLog`，则需要将其设置为`0x20`，且使`CClfsLogFcbPhysical:IsMultiplexed`返回`false`

![eStateIDA](/img/CVE-2022-37696/eStateIDA.png)

在这里，由于修改了`Fake Client Context`的偏移，因此最后`CLFS_LSN_INVALID:0xffffffff`恰好写入了`14th sector`的`signature`位置

![ResetLogIDA](/img/CVE-2022-37696/ResetLogIDA.png)

#### overwrite Signatures Offset

最后这个通过间接跳转走到`ClfsEncodeBlock`的地方，然后通过`encode`把`0x0050`和`0xffff`写回，最后导致`signaturesOffset`的值就被修改成了不合理的超大值

![FlushMetadataIDA](/img/CVE-2022-37696/FlushMetadataIDA.png)

整体的调用链如下所示

```
0: kd> k
 # Child-SP          RetAddr               Call Site
00 ffffeb07`b6f40fd8 fffff807`6e3a2232     CLFS!ClfsEncodeBlock
01 ffffeb07`b6f40fe0 fffff807`6e3999a0     CLFS!CClfsBaseFilePersisted::WriteMetadataBlock+0x152
02 ffffeb07`b6f41070 fffff807`6e37161f     CLFS!CClfsBaseFilePersisted::FlushImage+0x40
03 ffffeb07`b6f410b0 fffff807`6e373701     CLFS!CClfsLogFcbPhysical::FlushMetadata+0xef
04 ffffeb07`b6f41100 fffff807`6e39eaeb     CLFS!CClfsLogFcbPhysical::Initialize+0xc85
05 ffffeb07`b6f41240 fffff807`6e3a0a2b     CLFS!CClfsRequest::Create+0x4ef
06 ffffeb07`b6f41390 fffff807`6e3a07f7     CLFS!CClfsRequest::Dispatch+0x97
```

最后的写回`signArray`

![ClfsEncodeBlockPrivateIDA](/img/CVE-2022-37696/ClfsEncodeBlockPrivateIDA.png)

可以看到最后被修改成了`0xffff0050`

#### 畸形的 SignatureOffset 影响的整个过程总结

解析`signArray`，向`13th sector`写入`0x0050`，解析`fake client context`，使得`14th sector`写入`0xffff`，最后`ClfsEncodeBlockPrivate`，写回`signArray`，从而构造了一个超大值`signaturesOffset`

![Vuln](/img/CVE-2022-37696/Vuln.png)

## POC 分析

重新来看这个`POC`的图

![POC](/img/CVE-2022-37696/POC.png)

1. 初始化`MyLog.blf`
2. 堆风水布局，以使得后面的`MyLog`的堆块和`MyLxg_xxx`的堆块是连续的
3. 构造畸形的`MyLog.blf`，解析时，仍能打开`HANDLE`
4. 构造与`MyLog`堆块连续的堆块`MyLxg_xxx`
5. 给`MyLxg_xxx`添加`LogContainer`，在这个结构体中存在一个函数指针`pContainer`
6. 获取`NtSetInformationFile`的地址
7. 给`MyLog`添加`LogContainer`，此时已经可以溢出到`MyLxg_xxx`的`Container Context`的`pContainer`
8. 通过`NtSetInformationFile`设置`MyLxg_xxx`为`FileDispositionInformation`，即该函数将在文件关闭时删除文件或取消先前请求的删除，因此在关闭文件时，可以触发到`removeContainer`对`pContainer`的使用，从而触发`BSOD`
9. 触发漏洞

在扩大这个漏洞影响时，是覆盖了`SignaturesOffset`，而在`CClfsBaseFilePersisted::AllocSymbol`时，则利用`SignaturesOffset`做的检测

![AllocSymbolIDA](/img/CVE-2022-37696/AllocSymbolIDA.png)

因此此时，可以直接绕过这个检测，使得`cbSymbolZone`可以为一个大值，从而覆盖到下一个堆块的`pContainer`

![OOBW](/img/CVE-2022-37696/OOBW.png)

最后漏洞触发是在关闭`blf`文件时，在函数`CClfsBaseFilePersisted::RemoveContainer`中，会直接使用`pContainer`的虚表进行函数调用，而被破坏的`pContainer`会导致`BSOD`甚至`EOP`

## patch

该漏洞的`patch`，在`CClfsBaseFilePersisted::LoadContainerQ`时，对于`cbSymbolZone`和`signaturesOffset`进行了检测

```
1: kd> k
 # Child-SP          RetAddr               Call Site
00 ffff810c`a0c44fa0 fffff805`373b2176     CLFS!CClfsBaseFilePersisted::LoadContainerQ+0x1b2
01 ffff810c`a0c45100 fffff805`373df093     CLFS!CClfsLogFcbPhysical::Initialize+0x6da
02 ffff810c`a0c45240 fffff805`373e0aeb     CLFS!CClfsRequest::Create+0x4ef
```

![patch](/img/CVE-2022-37696/patch.png)

`CClfsBaseFilePersisted::LoadContainerQ`函数在`CClfsLogFcbPhysical::Initialize`函数中，位于`ResetLog`之后，`ClfsEncodeBlock`之前

## 总结

该漏洞利用不正确的`SignaturesOffset`，仅仅能写`0xffffffff`的利用，扩大到再次修改`SignaturesOffset`，从而直接导致溢出

## 参考

> https://www.zscaler.com/blogs/security-research/technical-analysis-windows-clfs-zero-day-vulnerability-cve-2022-37969-part
> https://github.com/ionescu007/clfs-docs/blob/main/README.md
> https://www.slideshare.net/PeterHlavaty/deathnote-of-microsoft-windows-kernel
